---
id: prd-cp-02182200-dispatch-memory
version: 1.0.0
created: 2026-02-18
updated: 2026-02-18
changelog:
  - 1.0.0: 初始版本 - 决策前记忆检索集成缺口分析
---

# PRD: 决策前记忆检索集成缺口分析与方案设计

## 一、现状分析

### 1.1 已实现的记忆检索

#### thalamus.js（已实现 ✅）

**位置**: `brain/src/thalamus.js:363`

```js
const learnings = await searchRelevantLearnings({
  task_type: event.task?.task_type,
  failure_class: event.failure_info?.class,
  event_type: event.type
}, 20);
```

- 每次 `analyzeEvent()` 调用前，自动检索 learnings 表
- 使用关键词评分（task_type、failure_class、event_type 三维匹配）
- 最多注入 20 条，格式化后插入 Sonnet prompt 的 `## 系统历史经验` 块
- 有 fallback（`getRecentLearnings`）

#### cortex.js（部分实现，依赖 thalamus 注入）

- Cortex 分析时依赖从 thalamus 调用链传递的上下文
- 没有独立的记忆检索调用

---

### 1.2 缺口分析

#### dispatchNextTask（未实现 ❌）

**位置**: `brain/src/tick.js:608-800`

dispatch 流程的决策序列：

```
0. drain/billing check（纯代码）
0b. low_success_rate check（dispatch-stats）
0c. slot budget check（并发槽位）
2. circuit breaker check（纯代码）
3. selectNextDispatchableTask()  ← 选任务
3a. requires_cortex 分支（Cortex RCA）
3b. preFlightCheck()             ← 任务质量检查（仅静态校验）
4. updateTask() to in_progress
5. triggerCeceliaRun()           ← 真正派发
```

**关键发现**：

1. `preFlightCheck()` **只做静态校验**（标题长度、描述长度、优先级有效性、skill 白名单、占位符检测），**没有任何历史记忆注入**
2. `selectNextDispatchableTask()` 选任务时只看优先级/依赖关系，**不参考历史成功率**
3. 派发前**没有类似任务的失败模式提示**

#### preFlightCheck（纯静态，无历史上下文 ❌）

**位置**: `brain/src/pre-flight-check.js`

当前检查项：
- Check 1: title 长度（≥5字符）
- Check 2: description 长度（≥20字符）
- Check 3: priority 有效性（P0/P1/P2）
- Check 4: skill 有效性（/dev/qa/audit/review）
- Check 5: 占位符文本检测

**缺失**：
- 无历史失败原因参考
- 无类似任务的成功/失败率
- 无 skill 历史表现数据

---

### 1.3 现有记忆系统能力

#### learning.js - `searchRelevantLearnings()`

- **数据来源**: `learnings` 表（Cortex RCA 生成的学习记录）
- **匹配维度**: task_type、failure_class、event_type、freshness
- **无 OpenAI 依赖**：纯 PostgreSQL 关键词评分
- **返回**: 最多 N 条，带 relevance_score
- **性能**: O(100) 内存评分，极快（<5ms）

#### memory-service.js + similarity.js - `searchWithVectors()`

- **数据来源**: `tasks` 表（已完成任务）
- **匹配方式**: pgvector（语义）+ Jaccard（关键词）混合搜索（70%+30%）
- **OpenAI 依赖**: 需要调用 `generateEmbedding()`，可能 100-500ms
- **fallback**: OpenAI 失败时降级到纯 Jaccard
- **返回**: 相似任务的 title、status、similarity 分数

---

## 二、推荐集成方案

### 方案设计原则

1. **不阻塞 dispatch**：记忆检索失败不能阻止任务派发
2. **性能安全**：优先使用不依赖外部 API 的检索方式
3. **渐进增强**：先注入 learnings（无 API 依赖），再可选注入向量搜索结果

### 2.1 推荐注入点：preFlightCheck 增强

**位置**: `brain/src/pre-flight-check.js`
**时机**: 在 static checks 通过后，追加历史上下文检查

```js
// Check 6: Historical context (非阻塞，仅日志/警告)
const histContext = await fetchHistoricalContext(task);
if (histContext.hasSimilarFailures) {
  // 记录到 metadata 警告，不 fail check
  warnings.push(`类似任务历史失败率: ${histContext.failureRate}`);
  suggestions.push(`参考失败原因: ${histContext.topFailureReason}`);
}
```

### 2.2 数据注入策略

**注入到 task.metadata**（`pre_flight_warnings` 字段）：

```json
{
  "pre_flight_warnings": [
    "历史类似任务失败率 60%，主要失败原因: 依赖缺失"
  ],
  "historical_context": {
    "similar_failures": 3,
    "similar_successes": 2,
    "top_failure_reason": "依赖缺失",
    "relevant_learnings_count": 5
  }
}
```

注入到 `working_memory` 以供 Cortex 读取（仅在 Cortex 路径时）。

### 2.3 具体检索函数设计

#### `fetchDispatchContext(task)` - 新增函数

**位置**: 新文件 `brain/src/dispatch-context.js`

```js
export async function fetchDispatchContext(task) {
  // 1. 搜索相关 learnings（快速，无 API 依赖）
  const learnings = await searchRelevantLearnings({
    task_type: task.task_type || task.metadata?.task_type,
    failure_class: null,
    event_type: 'task_failed'
  }, 5);

  // 2. 搜索历史类似任务成功率（SQL，无 API 依赖）
  const similarTaskStats = await pool.query(`
    SELECT
      status,
      COUNT(*) as count,
      jsonb_agg(metadata->'failure_reason') as failure_reasons
    FROM tasks
    WHERE title % $1  -- pg_trgm 相似度
       OR to_tsvector('chinese', title) @@ plainto_tsquery('chinese', $1)
    GROUP BY status
  `, [task.title]);

  // 3. (可选) 向量搜索 - 仅在 OPENAI_API_KEY 存在时
  // 延迟 500ms 超时保护，失败降级忽略

  return {
    learnings,
    similarTaskStats,
    hasSimilarFailures: /* computed */,
    failureRate: /* computed */
  };
}
```

---

## 三、实现任务拆分

### Task 1: `dispatch-context.js` - 历史上下文检索模块

**复杂度**: Medium
**依赖**: `learning.js`、`db.js`
**输出**: `fetchDispatchContext(task)` 函数

**具体工作**：
- 封装 `searchRelevantLearnings` 调用（task 维度）
- 封装 SQL 查询类似任务成功/失败率
- 提供统一返回格式
- 测试: mock learning + DB query，验证返回格式

### Task 2: `pre-flight-check.js` - 增加历史上下文检查

**复杂度**: Small
**依赖**: Task 1 的 `fetchDispatchContext`
**输出**: preFlightCheck 增加 `warnings` 字段，注入历史上下文

**具体工作**：
- 在现有 static checks 后追加 `fetchDispatchContext` 调用
- 注入结果到 `warnings`（不影响 passed/failed 决策）
- 返回值增加 `warnings: []` 字段
- 更新 tick.js 处理 warnings（写入 metadata）
- 测试: 验证 warning 不阻塞 dispatch

### Task 3: 更新 `dispatchNextTask` 记录 historical_context

**复杂度**: Small
**依赖**: Task 2
**输出**: dispatch 时将历史上下文写入 task.metadata

**具体工作**：
- 在 preFlightCheck 返回 warnings 时，更新 task.metadata
- 在 logTickDecision 中包含 warnings 信息
- 测试: 验证 metadata 写入正确

---

## 四、风险与 Fallback 策略

### 4.1 性能风险

| 操作 | 预期延迟 | 风险 |
|------|---------|------|
| searchRelevantLearnings | <5ms | 极低（内存评分） |
| SQL 类似任务统计 | 5-20ms | 低（简单聚合） |
| searchWithVectors（OpenAI） | 100-500ms | 高（外部 API） |

**决策**：
- Phase 1 只用前两个（无 OpenAI 依赖）
- 向量搜索作为 Phase 2 可选增强，带超时保护

### 4.2 Fallback 策略

```js
async function fetchDispatchContext(task) {
  try {
    // 主路径
    const learnings = await searchRelevantLearnings(...);
    return { learnings, ... };
  } catch (err) {
    // 完全降级：返回空上下文，不影响 dispatch
    console.warn('[dispatch-context] Fallback to empty context:', err.message);
    return { learnings: [], hasSimilarFailures: false, failureRate: null };
  }
}
```

### 4.3 不阻塞原则

**关键**：历史上下文检索的任何失败都**不能影响 `preFlightCheck.passed`** 的结果。

```js
// preFlightCheck 最终返回
return {
  passed: issues.length === 0,  // 只由 static checks 决定
  issues,
  suggestions,
  warnings  // 历史上下文警告，不影响 passed
};
```

---

## 五、与现有架构的兼容性

### 5.1 不需要修改的部分

- thalamus.js：已有 learnings 注入，保持不变
- cortex.js：分析时依赖 thalamus 上下文，保持不变
- learning.js：复用 `searchRelevantLearnings`，不需要修改
- similarity.js / memory-service.js：向量搜索在 Phase 2 可选接入

### 5.2 需要修改的部分

| 文件 | 变更类型 | 说明 |
|------|---------|------|
| `brain/src/pre-flight-check.js` | 增强 | 增加 `warnings` 字段，调用历史上下文 |
| `brain/src/tick.js` | 小修改 | 处理 preFlightCheck 返回的 warnings |
| `brain/src/dispatch-context.js` | 新增 | 历史上下文检索模块 |

### 5.3 测试覆盖要求

- `pre-flight-check.test.js`：增加 historical context 测试用例
- 新增 `dispatch-context.test.js`：测试检索函数和 fallback
- `tick.test.js`：验证 dispatch 时 warnings 的记录

---

## 六、summary

**核心问题**: dispatch 决策是"盲的"——不知道同类任务的历史失败模式。

**推荐方案**:
1. 新增 `dispatch-context.js` 封装历史检索
2. 增强 `preFlightCheck` 返回 `warnings` 字段（不阻塞）
3. `dispatchNextTask` 将 warnings 写入 task.metadata

**不推荐**:
- 在 dispatch 流程中加 LLM 调用（延迟太高）
- 用向量搜索（OpenAI API 依赖，Phase 1 跳过）
- 让 warnings 影响 passed 判断（违反不阻塞原则）

**预计工作量**: 3 个小任务，每个 <2h，合计约半天。
