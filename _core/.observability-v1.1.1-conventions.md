---
id: observability-v1.1.1-conventions
version: 1.1.1
created: 2026-02-12
updated: 2026-02-12
changelog:
  - 1.1.1: è¡¥å……ç¡¬è¾¹ç•Œå’Œé»˜è®¤çº¦å®š - é˜²æ­¢å®æ–½æ—¶èµ°ç¥
---

# Cecelia Core å¯è§‚æµ‹æ€§ v1.1.1 - ç¡¬è¾¹ç•Œä¸é»˜è®¤çº¦å®š

æœ¬æ–‡æ¡£æ˜¯ v1.1 çš„è¡¥å……ï¼Œå®šä¹‰**å¿…é¡»éµå®ˆçš„ç¡¬è¾¹ç•Œ**å’Œ**é»˜è®¤çº¦å®š**ï¼Œé˜²æ­¢å®æ–½æ—¶è¸©å‘ã€‚

---

## ğŸš¨ 8 ä¸ªç¡¬è¾¹ç•Œï¼ˆCRITICAL - å¿…é¡»éµå®ˆï¼‰

### 1. run_id ç”Ÿæˆç‚¹ï¼ˆå”¯ä¸€æ ‡å‡†ï¼‰

**è§„åˆ™**ï¼š
- âœ… `run_id` **åªèƒ½**åœ¨ L0ï¼ˆorchestrator å…¥å£ï¼‰ç”Ÿæˆ
- âœ… L1/L2/L3/L4 **åªèƒ½ç»§æ‰¿** run_id
- âŒ **ç¦æ­¢**å­ç³»ç»Ÿè‡ªè¡Œç”Ÿæˆ run_id

**å®æ–½**ï¼š
```javascript
// âœ… æ­£ç¡®ï¼šL0 ç”Ÿæˆ
// N8N workflow / Brain tick å…¥å£
const run_id = uuidv4();
await withSpan({ run_id, layer: 'L0_orchestrator', step_name: 'trigger_task' }, ...);

// âœ… æ­£ç¡®ï¼šL2 ç»§æ‰¿
// Executor æ¥æ”¶ä¸Šæ¸¸ä¼ æ¥çš„ run_id
await withSpan({ run_id: inherited_run_id, layer: 'L2_executor', step_name: 'spawn_process' }, ...);

// âŒ é”™è¯¯ï¼šL2 è‡ªå·±ç”Ÿæˆ
const run_id = uuidv4();  // é”™ï¼è¿™æ ·ä¼šå¯¼è‡´ trace æ–­è£‚
```

**æ£€æŸ¥ç‚¹**ï¼š
- Brain tick.js ä¸­ï¼Œdispatch æ—¶ç”Ÿæˆ run_id
- Executor ä» payload ä¸­è¯»å– run_id
- Claude Code ä»ç¯å¢ƒå˜é‡è¯»å– run_id

---

### 2. span_id å”¯ä¸€æ€§ï¼ˆé˜²æ­¢è¦†ç›–ï¼‰

**è§„åˆ™**ï¼š
- âœ… æ¯æ¬¡ step æ‰§è¡Œ**å¿…é¡»ç”Ÿæˆæ–°çš„ span_id**
- âœ… `attempt` è¡¨ç¤º"åŒä¸€ä¸ª step_name åœ¨åŒä¸€ä¸ª parent_span ä¸‹ç¬¬å‡ æ¬¡"
- âŒ **ç¦æ­¢**ç”¨åŒä¸€ä¸ª span_id é‡å¤ start/end

**å®æ–½**ï¼š
```javascript
// âœ… æ­£ç¡®ï¼šé‡è¯•æ—¶ç”Ÿæˆæ–° span_id
async function retryableStep(run_id, parent_span_id, step_name, attempt = 1) {
  const span_id = uuidv4();  // æ¯æ¬¡éƒ½ç”Ÿæˆæ–°çš„
  await traceStep.start({ run_id, span_id, parent_span_id, step_name, attempt });
  // ...
}

// âŒ é”™è¯¯ï¼šé‡è¯•æ—¶å¤ç”¨ span_id
const span_id = uuidv4();
await traceStep.start({ span_id, ... });
// å¤±è´¥
await traceStep.end(span_id, 'failed');
// é‡è¯• - é”™ï¼åŒä¸€ä¸ª span_id ä¸èƒ½ start ä¸¤æ¬¡
await traceStep.start({ span_id, ... });  // è¿åå”¯ä¸€æ€§çº¦æŸ
```

**æ•°æ®åº“çº¦æŸ**ï¼š
```sql
CREATE UNIQUE INDEX idx_run_events_span_id_unique ON run_events(span_id);
```

**Dashboard ä¿è¯**ï¼š
- æ—¶é—´çº¿ä¸ä¼šå‡ºç°"ä¸€ä¸ªèŠ‚ç‚¹è¢«è¦†ç›–"
- èŠ‚ç‚¹å›¾ä¸ä¼šå‡ºç°"å¹½çµèŠ‚ç‚¹"

---

### 3. status çŠ¶æ€æœºçº¦æŸï¼ˆé˜²æ­¢ä¹±å†™ï¼‰

**å…è®¸çš„çŠ¶æ€è¿ç§»**ï¼š

```
queued â†’ running â†’ success (ç»ˆæ€)
              â†“â†’ failed (ç»ˆæ€)
              â†“â†’ blocked â†’ running
              â†“â†’ canceled (ç»ˆæ€)
```

**ç¦æ­¢çš„è¿ç§»**ï¼š
- âŒ success â†’ runningï¼ˆç»ˆæ€ä¸å¯é€†ï¼‰
- âŒ failed â†’ runningï¼ˆç»ˆæ€ä¸å¯é€†ï¼Œåº”åˆ›å»ºæ–° spanï¼‰
- âŒ queued â†’ successï¼ˆè·³è¿‡ runningï¼‰

**å…³äº retrying**ï¼š
- **ä¸ä½œä¸ºçŠ¶æ€**ï¼Œè€Œæ˜¯é€šè¿‡ `attempt > 1` è¡¨ç¤º
- é‡è¯•æ—¶åˆ›å»ºæ–° spanï¼Œparent_span_id æŒ‡å‘åŸ span

**å®æ–½**ï¼š
```javascript
// âœ… æ­£ç¡®ï¼šé€šè¿‡ attempt è¡¨ç¤ºé‡è¯•
async function executeWithRetry(run_id, step_name, maxAttempts = 3) {
  let lastError = null;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const result = await withSpan({
        run_id,
        step_name,
        attempt,
        parent_span_id: attempt > 1 ? previous_span_id : null
      }, async () => {
        // æ‰§è¡Œé€»è¾‘
      });

      return result; // æˆåŠŸï¼Œé€€å‡ºé‡è¯•

    } catch (err) {
      lastError = err;
      if (attempt < maxAttempts) {
        await sleep(1000 * attempt); // é€€é¿
      }
    }
  }

  throw lastError;
}

// âŒ é”™è¯¯ï¼šç”¨ retrying çŠ¶æ€
await traceStep.end(span_id, 'failed');
await traceStep.start({ span_id, status: 'retrying' });  // é”™ï¼
```

**æ•°æ®åº“çº¦æŸ**ï¼ˆå¯é€‰ï¼‰ï¼š
```sql
ALTER TABLE run_events ADD CONSTRAINT check_status_valid
CHECK (status IN ('queued', 'running', 'blocked', 'success', 'failed', 'canceled'));

-- é˜²æ­¢ç»ˆæ€è¢«ä¿®æ”¹ï¼ˆé€šè¿‡è§¦å‘å™¨ï¼‰
CREATE OR REPLACE FUNCTION prevent_terminal_state_change()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status IN ('success', 'failed', 'canceled') AND NEW.status != OLD.status THEN
        RAISE EXCEPTION 'Cannot change terminal state % to %', OLD.status, NEW.status;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_prevent_terminal_state_change
BEFORE UPDATE ON run_events
FOR EACH ROW
EXECUTE FUNCTION prevent_terminal_state_change();
```

---

### 4. å¿ƒè·³å†™å…¥è§„åˆ™ï¼ˆé˜²æ­¢è¯¯åˆ¤ stuckï¼‰

**è§„åˆ™**ï¼š
- âœ… å¿ƒè·³**åªå¯¹** `status IN ('running', 'blocked')` å†™å…¥
- âœ… ä¸€æ—¦ `end()`ï¼ˆsuccess/failed/canceledï¼‰ï¼Œ**ç«‹å³åœæ­¢å¿ƒè·³**
- âœ… stuck åˆ¤å®šï¼š`now - COALESCE(heartbeat_ts, ts_start) > 300`
- âœ… å¤šä¸ªå¹¶è¡Œ span æ—¶ï¼Œ`last_alive_span` å– activity æœ€æ–°è€…

**å®æ–½**ï¼š
```javascript
// withSpan() ä¸­çš„å¿ƒè·³ç®¡ç†
async function withSpan(config, fn) {
  const span = await start(config);

  // å¿ƒè·³ interval
  const heartbeatInterval = setInterval(() => {
    // åªå¯¹ running çŠ¶æ€å†™å¿ƒè·³
    heartbeat(span.span_id).catch(err => {
      console.error(`[trace] Heartbeat failed:`, err.message);
    });
  }, 30000);

  try {
    const result = await fn(spanHelpers);

    // âœ… æˆåŠŸåç«‹å³åœæ­¢å¿ƒè·³
    clearInterval(heartbeatInterval);

    await end(span.span_id, 'success', ...);
    return result;

  } catch (error) {
    // âœ… å¤±è´¥åç«‹å³åœæ­¢å¿ƒè·³
    clearInterval(heartbeatInterval);

    await end(span.span_id, 'failed', ...);
    throw error;
  }
}

// heartbeat() å‡½æ•°åªæ›´æ–° running çŠ¶æ€
async function heartbeat(span_id) {
  await db.query(
    `UPDATE run_events
     SET heartbeat_ts = now()
     WHERE span_id = $1 AND status IN ('running', 'blocked')`,  // â† å…³é”®çº¦æŸ
    [span_id]
  );
}
```

**v_run_last_alive_span è§†å›¾**ï¼š
```sql
-- ä½¿ç”¨ COALESCE(heartbeat_ts, ts_start) è®¡ç®—æœ€åæ´»è·ƒæ—¶é—´
CREATE OR REPLACE VIEW v_run_last_alive_span AS
WITH ranked_spans AS (
    SELECT
        run_id,
        span_id,
        layer,
        step_name,
        status,
        ts_start,
        heartbeat_ts,
        ROW_NUMBER() OVER (
            PARTITION BY run_id
            ORDER BY COALESCE(heartbeat_ts, ts_start) DESC  -- â† å…³é”®æ’åº
        ) AS rn
    FROM run_events
)
SELECT
    run_id,
    span_id,
    layer,
    step_name,
    status,
    heartbeat_ts,
    EXTRACT(EPOCH FROM (now() - COALESCE(heartbeat_ts, ts_start))) AS seconds_since_activity
FROM ranked_spans
WHERE rn = 1;
```

---

### 5. artifacts å¼•ç”¨æ–¹å¼ç»Ÿä¸€ï¼ˆé˜²æ­¢å¥‘çº¦æ¼‚ç§»ï¼‰

**è§„åˆ™**ï¼š
- âœ… `run_events.artifacts` **æ°¸è¿œæ˜¯** `jsonb map<string, uuid>`
- âœ… key å‘½åè§„èŒƒï¼š`<type>_id`ï¼ˆä¾‹å¦‚ï¼š`screenshot_id`, `log_id`, `html_id`ï¼‰
- âŒ **ç¦æ­¢**å­˜å‚¨è·¯å¾„ã€URLã€base64

**å®æ–½**ï¼š
```javascript
// âœ… æ­£ç¡®ï¼šå­˜å‚¨ artifact_id
const screenshot_id = await storeArtifact(span_id, 'screenshot', '/tmp/upload.png', 'image/png');
const log_id = await storeArtifact(span_id, 'log', '/tmp/upload.log', 'text/plain');

await end(span.span_id, 'success', null, null, null, {
  screenshot_id,   // â† UUID
  log_id          // â† UUID
});

// âŒ é”™è¯¯ï¼šå­˜å‚¨è·¯å¾„
await end(span.span_id, 'success', null, null, null, {
  screenshot: '/tmp/upload.png',  // é”™ï¼è·¨æœºå™¨ä¸å¯è®¿é—®
  log: 'http://localhost/log.txt'  // é”™ï¼hardcoded URL
});
```

**Frontend è®¿é—®**ï¼š
```typescript
// âœ… æ­£ç¡®ï¼šé€šè¿‡ä»£ç†ç«¯ç‚¹è®¿é—®
{span.artifacts && Object.entries(span.artifacts).map(([key, artifact_id]) => (
  <a href={`/api/brain/trace/artifacts/${artifact_id}`} target="_blank">
    ğŸ“ {key.replace('_id', '')}
  </a>
))}

// âŒ é”™è¯¯ï¼šç›´æ¥è®¿é—®è·¯å¾„
<a href={span.artifacts.screenshot}>  // é”™ï¼
```

**æ•°æ®åº“çº¦æŸ**ï¼ˆå¯é€‰ï¼‰ï¼š
```sql
-- ç¡®ä¿ artifacts çš„ key éƒ½ä»¥ _id ç»“å°¾
CREATE OR REPLACE FUNCTION validate_artifacts_format()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.artifacts IS NOT NULL THEN
        -- æ£€æŸ¥æ‰€æœ‰ key æ˜¯å¦ä»¥ _id ç»“å°¾
        IF EXISTS (
            SELECT 1 FROM jsonb_object_keys(NEW.artifacts) AS k
            WHERE k NOT LIKE '%_id'
        ) THEN
            RAISE EXCEPTION 'artifacts keys must end with _id (e.g., screenshot_id)';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_validate_artifacts
BEFORE INSERT OR UPDATE ON run_events
FOR EACH ROW
EXECUTE FUNCTION validate_artifacts_format();
```

---

### 6. executor_host è§„èŒƒï¼ˆé˜²æ­¢èšåˆå¤±è´¥ï¼‰

**æ ‡å‡†æšä¸¾**ï¼š
```
us-vps      - ç¾å›½ VPS (146.190.52.84)
hk-vps      - é¦™æ¸¯ VPS (43.154.85.217)
hk-n8n      - é¦™æ¸¯ N8N (Docker on hk-vps)
mac-mini    - Mac mini (æœ¬åœ°å¼€å‘æœº)
node-pc     - Node PC (å¤‡ç”¨æœº)
```

**è§„åˆ™**ï¼š
- âœ… `executor_host` ä½¿ç”¨æ ‡å‡†æšä¸¾ï¼ˆç”¨äº Dashboard èšåˆï¼‰
- âœ… `metadata.executor_id` å­˜å‚¨çœŸå® hostname/instance_idï¼ˆç”¨äºæ’æŸ¥ï¼‰
- âŒ **ç¦æ­¢**éšæ‰‹å­—ç¬¦ä¸²ï¼ˆå¦‚ `localhost`, `my-laptop`, `server1`ï¼‰

**å®æ–½**ï¼š
```javascript
// ç¯å¢ƒå˜é‡é…ç½®
// .env.us-vps
EXECUTOR_HOST=us-vps
EXECUTOR_ID=perfect21-us-vps-01

// .env.hk-vps
EXECUTOR_HOST=hk-vps
EXECUTOR_ID=cecelia-hk-prod

// trace.js è¯»å–
function getExecutorHost() {
  const host = process.env.EXECUTOR_HOST;

  // éªŒè¯æšä¸¾
  const validHosts = ['us-vps', 'hk-vps', 'hk-n8n', 'mac-mini', 'node-pc'];
  if (!validHosts.includes(host)) {
    console.warn(`[trace] Invalid EXECUTOR_HOST: ${host}, falling back to hostname`);
    return os.hostname();
  }

  return host;
}

// å­˜å‚¨çœŸå® hostname åˆ° metadata
await traceStep.start({
  executor_host: 'us-vps',  // æ ‡å‡†æšä¸¾
  metadata: {
    executor_id: process.env.EXECUTOR_ID || os.hostname(),  // çœŸå®æ ‡è¯†
    ip: getLocalIP()
  }
});
```

**Dashboard èšåˆ**ï¼š
```typescript
// æŒ‰ executor_host ç»Ÿè®¡
const hostStats = failures.reduce((acc, f) => {
  f.affected_hosts?.forEach(host => {
    acc[host] = (acc[host] || 0) + f.failure_count;
  });
  return acc;
}, {});

// æ˜¾ç¤ºï¼šus-vps (15 failures), hk-vps (3 failures)
```

---

### 7. reason_code è´£ä»»å½’å±ï¼ˆé˜²æ­¢åƒåœ¾å­—æ®µï¼‰

**è§„åˆ™**ï¼š
- âœ… `reason_code` **å¿…é¡»æ¥è‡ªæšä¸¾è¡¨**
- âœ… `classifyError()` åªèƒ½è¾“å‡ºæšä¸¾å€¼
- âœ… æœªè¯†åˆ«çš„ç»Ÿä¸€ä¸º `UNEXPECTED_ERROR` + `metadata.error_message`
- âœ… å»ºè®®ä½¿ç”¨ CHECK çº¦æŸæˆ– `reason_codes` è¡¨

**æ–¹æ¡ˆ Aï¼šCHECK çº¦æŸï¼ˆç®€å•ï¼‰**

```sql
ALTER TABLE run_events ADD CONSTRAINT check_reason_code_valid
CHECK (
    reason_code IS NULL OR
    reason_code IN (
        -- TRANSIENT
        'TIMEOUT', 'NETWORK_ERROR', 'DEADLOCK', 'RATE_LIMITED',
        -- PERSISTENT
        'MISSING_FILE', 'SELECTOR_NOT_FOUND', 'SYNTAX_ERROR', 'INVALID_INPUT',
        -- RESOURCE
        'OUT_OF_MEMORY', 'OUT_OF_DISK', 'CPU_THROTTLED',
        -- CONFIG
        'PERMISSION_DENIED', 'AUTH_EXPIRED', 'INVALID_CONFIG',
        -- UNKNOWN
        'UNEXPECTED_ERROR'
    )
);
```

**æ–¹æ¡ˆ Bï¼šreason_codes è¡¨ï¼ˆæ¨èï¼‰**

```sql
CREATE TABLE reason_codes (
    code VARCHAR(100) PRIMARY KEY,
    kind VARCHAR(20) NOT NULL CHECK (kind IN ('TRANSIENT', 'PERSISTENT', 'RESOURCE', 'CONFIG', 'UNKNOWN')),
    description TEXT,
    auto_retry BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- æ’å…¥æ ‡å‡† reason_code
INSERT INTO reason_codes (code, kind, auto_retry, description) VALUES
-- TRANSIENT (auto-retry)
('TIMEOUT', 'TRANSIENT', true, 'Operation timed out'),
('NETWORK_ERROR', 'TRANSIENT', true, 'Network connection failed'),
('DEADLOCK', 'TRANSIENT', true, 'Database deadlock detected'),
('RATE_LIMITED', 'TRANSIENT', true, 'Rate limit exceeded'),

-- PERSISTENT (manual fix)
('MISSING_FILE', 'PERSISTENT', false, 'Required file not found'),
('SELECTOR_NOT_FOUND', 'PERSISTENT', false, 'DOM selector not found'),
('SYNTAX_ERROR', 'PERSISTENT', false, 'Code syntax error'),
('INVALID_INPUT', 'PERSISTENT', false, 'Invalid input data'),

-- RESOURCE (scale up)
('OUT_OF_MEMORY', 'RESOURCE', false, 'Out of memory'),
('OUT_OF_DISK', 'RESOURCE', false, 'Disk space exhausted'),
('CPU_THROTTLED', 'RESOURCE', false, 'CPU throttled'),

-- CONFIG (fix config)
('PERMISSION_DENIED', 'CONFIG', false, 'Permission denied'),
('AUTH_EXPIRED', 'CONFIG', false, 'Authentication expired'),
('INVALID_CONFIG', 'CONFIG', false, 'Invalid configuration'),

-- UNKNOWN
('UNEXPECTED_ERROR', 'UNKNOWN', false, 'Unclassified error');

-- å¤–é”®çº¦æŸ
ALTER TABLE run_events ADD CONSTRAINT fk_reason_code
FOREIGN KEY (reason_code) REFERENCES reason_codes(code);
```

**å®æ–½**ï¼š
```javascript
// classifyError() å¼ºåˆ¶ä½¿ç”¨æšä¸¾
const VALID_REASON_CODES = new Set([
  'TIMEOUT', 'NETWORK_ERROR', 'DEADLOCK', 'RATE_LIMITED',
  'MISSING_FILE', 'SELECTOR_NOT_FOUND', 'SYNTAX_ERROR', 'INVALID_INPUT',
  'OUT_OF_MEMORY', 'OUT_OF_DISK', 'CPU_THROTTLED',
  'PERMISSION_DENIED', 'AUTH_EXPIRED', 'INVALID_CONFIG',
  'UNEXPECTED_ERROR'
]);

function classifyError(error) {
  const message = error.message?.toLowerCase() || '';

  let reason_code = 'UNEXPECTED_ERROR';
  let reason_kind = 'UNKNOWN';

  // åˆ†ç±»é€»è¾‘...
  if (message.includes('timeout')) {
    reason_code = 'TIMEOUT';
    reason_kind = 'TRANSIENT';
  }
  // ...

  // âœ… éªŒè¯æšä¸¾
  if (!VALID_REASON_CODES.has(reason_code)) {
    console.warn(`[trace] Invalid reason_code: ${reason_code}, using UNEXPECTED_ERROR`);
    reason_code = 'UNEXPECTED_ERROR';
    reason_kind = 'UNKNOWN';
  }

  return { reason_code, reason_kind, error_message: error.message };
}
```

**Dashboard ä½¿ç”¨**ï¼š
```typescript
// è‡ªåŠ¨é‡è¯• TRANSIENT å¤±è´¥
const retryable = await fetch('/api/brain/trace/failures/top').then(r => r.json());
const transientFailures = retryable.filter(f => f.reason_kind === 'TRANSIENT');

<button onClick={() => retryTransientFailures(transientFailures)}>
  ğŸ”„ é‡è¯• {transientFailures.length} ä¸ª TRANSIENT å¤±è´¥
</button>
```

---

### 8. GC åˆ é™¤é¡ºåºï¼ˆé˜²æ­¢æ–­å¼•ç”¨ï¼‰

**æ ‡å‡†æµç¨‹**ï¼ˆæŒ‰é¡ºåºæ‰§è¡Œï¼‰ï¼š

```
1. DB æ ‡è®° run_events.metadata.gc_at (+ gc_batch_id)
   â†“
2. åˆ é™¤/å½’æ¡£ run_artifacts (å…ˆå¤‡ä»½åˆ° S3/NASï¼Œå† DELETE)
   â†“
3. åˆ é™¤æœ¬åœ°æ–‡ä»¶ /tmp/cecelia-runs/<run_id>/
   â†“
4. (å¯é€‰) åˆ é™¤ run_events æˆ–åªä¿ç•™ summary
```

**å®æ–½**ï¼š
```javascript
// brain/scripts/gc-runs.js
async function cleanupExpiredRuns(daysThreshold = 7) {
  const gc_batch_id = uuidv4();

  // Step 1: æ ‡è®°å¾…æ¸…ç†çš„ runs
  const expiredRuns = await db.query(`
    UPDATE run_events
    SET metadata = jsonb_set(
      COALESCE(metadata, '{}'::jsonb),
      '{gc_batch_id}', to_jsonb($1::text)
    ) || jsonb_build_object('gc_at', now())
    WHERE run_id IN (
      SELECT run_id FROM v_run_summary
      WHERE overall_status IN ('success', 'failed', 'partial')
        AND run_end_or_now < now() - ($2 || ' days')::interval
    )
    RETURNING run_id
  `, [gc_batch_id, daysThreshold]);

  console.log(`[GC] Marked ${expiredRuns.rows.length} runs for cleanup (batch: ${gc_batch_id})`);

  // Step 2: å½’æ¡£ artifacts
  for (const { run_id } of expiredRuns.rows) {
    const artifacts = await db.query(
      `SELECT * FROM run_artifacts WHERE span_id IN (
        SELECT span_id FROM run_events WHERE run_id = $1
      )`,
      [run_id]
    );

    for (const artifact of artifacts.rows) {
      // å¤‡ä»½åˆ° S3/NASï¼ˆå¦‚æœé…ç½®ï¼‰
      if (process.env.ARTIFACT_ARCHIVE_ENABLED === 'true') {
        await archiveArtifact(artifact);
      }

      // åˆ é™¤ DB è®°å½•
      await db.query(`DELETE FROM run_artifacts WHERE id = $1`, [artifact.id]);
    }
  }

  // Step 3: åˆ é™¤æœ¬åœ°æ–‡ä»¶
  for (const { run_id } of expiredRuns.rows) {
    const runDir = `/tmp/cecelia-runs/${run_id}`;
    try {
      await fs.rm(runDir, { recursive: true, force: true });
      console.log(`[GC] Deleted directory: ${runDir}`);
    } catch (err) {
      console.error(`[GC] Failed to delete ${runDir}:`, err.message);
    }
  }

  // Step 4 (å¯é€‰): åˆ é™¤ run_events æˆ–å‹ç¼©
  if (process.env.GC_DELETE_RUN_EVENTS === 'true') {
    await db.query(
      `DELETE FROM run_events
       WHERE metadata->>'gc_batch_id' = $1`,
      [gc_batch_id]
    );
  } else {
    console.log(`[GC] Kept run_events for audit (only marked gc_at)`);
  }

  console.log(`[GC] Cleanup completed for batch ${gc_batch_id}`);
}

async function archiveArtifact(artifact) {
  // å®ç° S3/NAS å½’æ¡£
  if (artifact.storage_backend === 'local') {
    // ä¸Šä¼ åˆ° S3
    const s3Key = `archive/${artifact.span_id}/${artifact.artifact_type}`;
    await uploadToS3(artifact.storage_key, s3Key);
  }
}
```

**é˜²æ­¢æ–­å¼•ç”¨**ï¼š
- âœ… å…ˆåˆ  artifacts è¡¨ï¼Œå†åˆ æ–‡ä»¶
- âœ… å…ˆåˆ æ–‡ä»¶ï¼Œå†åˆ  run_eventsï¼ˆå¯é€‰ï¼‰
- âŒ ä¸èƒ½å…ˆåˆ  run_eventsï¼Œå¯¼è‡´ artifacts æˆä¸ºå­¤å„¿

---

## ğŸ”§ SQL/API å…³é”®è¡¥å……

### A. å¼ºçº¦æŸç´¢å¼•ï¼ˆæ€§èƒ½ä¿è¯ï¼‰

```sql
-- ç´¢å¼• 1: run æ´»è·ƒåº¦æ’åºï¼ˆç”¨äº last_alive_span æŸ¥è¯¢ï¼‰
CREATE INDEX idx_run_events_run_activity
ON run_events(run_id, COALESCE(heartbeat_ts, ts_start) DESC);

-- ç´¢å¼• 2: æŒ‰çŠ¶æ€å’Œå±‚çº§æŸ¥è¯¢ï¼ˆç”¨äº Dashboard èšåˆï¼‰
CREATE INDEX idx_run_events_status_layer
ON run_events(status, layer);

-- ç´¢å¼• 3: task â†’ runs æŸ¥è¯¢ï¼ˆæŸ¥çœ‹ä»»åŠ¡çš„æ‰€æœ‰é‡è¯•ï¼‰
CREATE INDEX idx_run_events_task_run
ON run_events(task_id, run_id)
WHERE task_id IS NOT NULL;

-- ç´¢å¼• 4: æ—¶é—´èŒƒå›´æŸ¥è¯¢ï¼ˆç”¨äº top_failure_reasonsï¼‰
CREATE INDEX idx_run_events_ts_start_status
ON run_events(ts_start DESC, status)
WHERE status IN ('failed', 'success');
```

---

### B. overall_status å®šä¹‰å£å¾„ï¼ˆæ˜ç¡®è®¡ç®—è§„åˆ™ï¼‰

```sql
CREATE OR REPLACE VIEW v_run_summary AS
SELECT
    run_id,
    task_id,
    MIN(ts_start) AS run_start,
    MAX(COALESCE(ts_end, now())) AS run_end_or_now,
    COUNT(*) AS total_spans,
    COUNT(*) FILTER (WHERE status = 'success') AS success_spans,
    COUNT(*) FILTER (WHERE status = 'failed') AS failed_spans,
    COUNT(*) FILTER (WHERE status = 'running') AS running_spans,
    COUNT(*) FILTER (WHERE status = 'blocked') AS blocked_spans,
    COUNT(*) FILTER (WHERE status = 'canceled') AS canceled_spans,
    ARRAY_AGG(DISTINCT layer ORDER BY layer) AS layers_involved,
    ARRAY_AGG(DISTINCT executor_host ORDER BY executor_host) FILTER (WHERE executor_host IS NOT NULL) AS hosts_involved,
    MAX(heartbeat_ts) AS last_heartbeat,

    -- overall_status è®¡ç®—å£å¾„ï¼ˆä¼˜å…ˆçº§ï¼šfailed > running > canceled > successï¼‰
    CASE
        WHEN COUNT(*) FILTER (WHERE status = 'failed') > 0 THEN 'failed'
        WHEN COUNT(*) FILTER (WHERE status IN ('running', 'blocked', 'queued')) > 0 THEN 'running'
        WHEN COUNT(*) FILTER (WHERE status = 'canceled') > 0 THEN 'canceled'
        WHEN COUNT(*) FILTER (WHERE status = 'success') = COUNT(*) THEN 'success'
        ELSE 'partial'
    END AS overall_status
FROM run_events
GROUP BY run_id, task_id;
```

**å£å¾„è¯´æ˜**ï¼š
1. **ä»»æ„ span failed** â†’ `overall_status = 'failed'`
2. **å¦åˆ™ï¼Œä»»æ„ span running/blocked/queued** â†’ `overall_status = 'running'`
3. **å¦åˆ™ï¼Œä»»æ„ span canceled** â†’ `overall_status = 'canceled'`
4. **å¦åˆ™ï¼Œå…¨éƒ¨ span success** â†’ `overall_status = 'success'`
5. **å…¶ä»–æƒ…å†µ**ï¼ˆç†è®ºä¸åº”å‡ºç°ï¼‰â†’ `overall_status = 'partial'`

---

### C. artifacts ä»£ç†å®‰å…¨è¾¹ç•Œ

```javascript
// routes/trace.js
router.get('/artifacts/:id', async (req, res) => {
  const { id } = req.params;

  // 1. æŸ¥è¯¢ artifact å…ƒæ•°æ®
  const artifact = await getArtifactMetadata(id);
  if (!artifact) {
    return res.status(404).json({ error: 'Artifact not found' });
  }

  // 2. æ£€æŸ¥è¿‡æœŸ
  if (artifact.expires_at && new Date(artifact.expires_at) < new Date()) {
    return res.status(410).json({ error: 'Artifact expired' });
  }

  // 3. âœ… æƒé™æ ¡éªŒï¼ˆè‡³å°‘åšå†…ç½‘é™åˆ¶ï¼‰
  const clientIP = req.ip || req.connection.remoteAddress;
  const allowedIPs = ['127.0.0.1', '::1', '10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16'];

  if (!isIPAllowed(clientIP, allowedIPs)) {
    return res.status(403).json({ error: 'Access denied - internal only' });
  }

  // 4. âœ… è·¯å¾„å®‰å…¨æ£€æŸ¥ï¼ˆé˜²æ­¢ä»»æ„æ–‡ä»¶è¯»å–ï¼‰
  if (artifact.storage_backend === 'local') {
    const allowedRoots = ['/tmp/cecelia-runs/', '/opt/cecelia/artifacts/'];
    const normalizedPath = path.normalize(artifact.storage_key);

    if (!allowedRoots.some(root => normalizedPath.startsWith(root))) {
      console.error(`[trace] Blocked access to path outside allowed roots: ${normalizedPath}`);
      return res.status(403).json({ error: 'Invalid artifact path' });
    }

    // æ£€æŸ¥æ–‡ä»¶å­˜åœ¨
    if (!await fs.stat(normalizedPath).catch(() => null)) {
      return res.status(404).json({ error: 'Artifact file not found' });
    }

    // å‘é€æ–‡ä»¶
    res.sendFile(normalizedPath);

  } else if (artifact.storage_backend === 's3') {
    // ç”Ÿæˆç­¾å URLï¼ˆæœ‰æ•ˆæœŸ 5 åˆ†é’Ÿï¼‰
    const signedUrl = await generateS3SignedUrl(artifact.storage_key, 300);
    res.redirect(signedUrl);

  } else if (artifact.storage_backend === 'nas') {
    // NAS è·¯å¾„ä¹Ÿéœ€è¦æ£€æŸ¥
    const allowedNASRoots = ['/mnt/nas/cecelia-artifacts/'];
    const normalizedPath = path.normalize(artifact.storage_key);

    if (!allowedNASRoots.some(root => normalizedPath.startsWith(root))) {
      return res.status(403).json({ error: 'Invalid NAS path' });
    }

    res.sendFile(normalizedPath);
  }
});

function isIPAllowed(ip, allowedPatterns) {
  // ç®€åŒ–å®ç°ï¼Œç”Ÿäº§åº”ä½¿ç”¨ ip-range-check åº“
  return allowedPatterns.includes(ip) ||
         ip.startsWith('127.') ||
         ip === '::1' ||
         ip.startsWith('192.168.');
}
```

---

## ğŸ è¶…ä½æˆæœ¬å¢å¼ºï¼šrun æ ‡ç­¾ç³»ç»Ÿ

### ç”¨é€”

è§£å†³**"å“ªä¸ªæ˜¯åƒåœ¾å“ªä¸ªæ˜¯ä¸»çº¿"**çš„é—®é¢˜ã€‚

### å®æ–½

```sql
-- åœ¨ run_events æˆ– tasks è¡¨æ·»åŠ  tags å­—æ®µ
ALTER TABLE run_events ADD COLUMN tags TEXT[];
CREATE INDEX idx_run_events_tags ON run_events USING gin(tags);

-- æˆ–åœ¨ metadata ä¸­å­˜å‚¨
UPDATE run_events SET metadata = jsonb_set(
  COALESCE(metadata, '{}'::jsonb),
  '{tags}', '["mainline", "publish", "xhs"]'::jsonb
) WHERE run_id = '...';
```

### æ ‡å‡† tags

```javascript
const STANDARD_TAGS = {
  // ç±»å‹
  mainline: 'ä¸»çº¿æµç¨‹',
  experimental: 'å®éªŒæ€§åŠŸèƒ½',
  hotfix: 'ç´§æ€¥ä¿®å¤',

  // åœºæ™¯
  publish: 'å‘å¸ƒä»»åŠ¡',
  test: 'æµ‹è¯•ä»»åŠ¡',
  debug: 'è°ƒè¯•ä»»åŠ¡',

  // å¹³å°
  xhs: 'å°çº¢ä¹¦',
  toutiao: 'ä»Šæ—¥å¤´æ¡',
  douyin: 'æŠ–éŸ³',

  // è‡ªåŠ¨åŒ–
  'retry:auto': 'è‡ªåŠ¨é‡è¯•',
  'retry:manual': 'æ‰‹åŠ¨é‡è¯•',
  'scheduled': 'å®šæ—¶ä»»åŠ¡',
  'manual': 'æ‰‹åŠ¨è§¦å‘'
};
```

### Dashboard ä½¿ç”¨

```typescript
// Filter ç»„ä»¶
function RunsOverview() {
  const [selectedTags, setSelectedTags] = useState(['mainline']);

  const { data: runs } = useApi('/api/brain/trace/runs/active', {
    params: { tags: selectedTags.join(',') }
  });

  return (
    <div>
      <TagFilter tags={STANDARD_TAGS} selected={selectedTags} onChange={setSelectedTags} />

      {/* åªæ˜¾ç¤º mainline ä»»åŠ¡ */}
      <RunsList runs={runs} />
    </div>
  );
}

// API ç«¯ç‚¹æ”¯æŒ
router.get('/runs/active', async (req, res) => {
  const { tags } = req.query;

  let query = `SELECT * FROM v_active_runs`;
  const params = [];

  if (tags) {
    const tagArray = tags.split(',');
    query += ` WHERE tags && $1`;  // PostgreSQL æ•°ç»„é‡å æ“ä½œç¬¦
    params.push(tagArray);
  }

  const result = await db.query(query, params);
  res.json(result.rows);
});
```

---

## ğŸ“‹ v1.1.1 å®Œæ•´æ£€æŸ¥æ¸…å•

### ä»£ç å®æ–½å‰

- [ ] å®šä¹‰ EXECUTOR_HOST æšä¸¾ï¼ˆus-vps, hk-vps, hk-n8n, mac-mini, node-pcï¼‰
- [ ] å®šä¹‰ reason_code æšä¸¾ï¼ˆCHECK çº¦æŸæˆ– reason_codes è¡¨ï¼‰
- [ ] å®šä¹‰ allowed artifact æ ¹ç›®å½•ï¼ˆ/tmp/cecelia-runs/, /opt/cecelia/artifacts/ï¼‰
- [ ] å®šä¹‰çŠ¶æ€æœºè¿ç§»è§„åˆ™ï¼ˆæ–‡æ¡£ + å¯é€‰è§¦å‘å™¨ï¼‰

### æ•°æ®åº“å±‚

- [ ] æ·»åŠ  4 ä¸ªå¼ºçº¦æŸç´¢å¼•
- [ ] æ·»åŠ  artifacts æ ¼å¼éªŒè¯è§¦å‘å™¨ï¼ˆå¯é€‰ï¼‰
- [ ] æ·»åŠ  status çŠ¶æ€æœºçº¦æŸè§¦å‘å™¨ï¼ˆå¯é€‰ï¼‰
- [ ] åˆ›å»º reason_codes è¡¨ï¼ˆæ¨èï¼‰æˆ– CHECK çº¦æŸ
- [ ] åˆ›å»º tags å­—æ®µï¼ˆå¯é€‰ï¼‰

### SDK å±‚

- [ ] å¼ºåˆ¶ run_id ç»§æ‰¿æ£€æŸ¥
- [ ] span_id å”¯ä¸€æ€§ä¿è¯ï¼ˆæ¯æ¬¡ start ç”Ÿæˆæ–° UUIDï¼‰
- [ ] heartbeat() åªæ›´æ–° running/blocked
- [ ] withSpan() end åç«‹å³ clearInterval
- [ ] classifyError() éªŒè¯æšä¸¾
- [ ] storeArtifact() å­˜å‚¨ artifact_idï¼Œä¸å­˜è·¯å¾„
- [ ] getExecutorHost() éªŒè¯æšä¸¾

### API å±‚

- [ ] artifacts ä»£ç†ç«¯ç‚¹ï¼šIP ç™½åå• + è·¯å¾„éªŒè¯
- [ ] overall_status è®¡ç®—å£å¾„æ˜ç¡®
- [ ] æ”¯æŒ tags filterï¼ˆå¯é€‰ï¼‰

### Frontend å±‚

- [ ] last_alive_span é«˜äº®æ˜¾ç¤º
- [ ] reason_kind åˆ†ç»„æ˜¾ç¤º
- [ ] artifacts é€šè¿‡ä»£ç†è®¿é—®
- [ ] tags filterï¼ˆå¯é€‰ï¼‰

### GC è°ƒåº¦

- [ ] å®ç° 4 æ­¥åˆ é™¤é¡ºåº
- [ ] æ·»åŠ  archiveArtifact()ï¼ˆå¯é€‰ï¼‰
- [ ] é…ç½®å¤–éƒ¨è°ƒåº¦
- [ ] æµ‹è¯• advisory lock

---

## ğŸ“ æ›´æ–° DEFINITION.md

å°†ä»¥ä¸‹å†…å®¹æ·»åŠ åˆ° `DEFINITION.md`ï¼š

```markdown
## å¯è§‚æµ‹æ€§è§„èŒƒï¼ˆv1.1.1ï¼‰

### run_id ç”Ÿæˆç‚¹
- run_id **åªèƒ½**åœ¨ L0ï¼ˆorchestratorï¼‰ç”Ÿæˆ
- L1/L2/L3/L4 **åªèƒ½ç»§æ‰¿** run_id
- ç¦æ­¢å­ç³»ç»Ÿè‡ªè¡Œç”Ÿæˆ run_id

### span_id å”¯ä¸€æ€§
- æ¯æ¬¡ step æ‰§è¡Œå¿…é¡»ç”Ÿæˆæ–° span_id
- ç¦æ­¢å¤ç”¨ span_id

### executor_host æšä¸¾
- us-vps, hk-vps, hk-n8n, mac-mini, node-pc
- é€šè¿‡ç¯å¢ƒå˜é‡ EXECUTOR_HOST é…ç½®

### reason_code æšä¸¾
- TRANSIENT: TIMEOUT, NETWORK_ERROR, DEADLOCK, RATE_LIMITED
- PERSISTENT: MISSING_FILE, SELECTOR_NOT_FOUND, SYNTAX_ERROR, INVALID_INPUT
- RESOURCE: OUT_OF_MEMORY, OUT_OF_DISK, CPU_THROTTLED
- CONFIG: PERMISSION_DENIED, AUTH_EXPIRED, INVALID_CONFIG
- UNKNOWN: UNEXPECTED_ERROR

### artifacts è§„èŒƒ
- æ°¸è¿œæ˜¯ jsonb map<string, uuid>
- key å‘½åï¼š<type>_id
- ç¦æ­¢å­˜å‚¨è·¯å¾„/URL

### GC åˆ é™¤é¡ºåº
1. æ ‡è®° gc_at + gc_batch_id
2. åˆ é™¤/å½’æ¡£ run_artifacts
3. åˆ é™¤æœ¬åœ°æ–‡ä»¶
4. åˆ é™¤ run_eventsï¼ˆå¯é€‰ï¼‰
```

---

## æ€»ç»“

v1.1.1 è¡¥å……äº† **8 ä¸ªç¡¬è¾¹ç•Œ** å’Œ **3 ä¸ªå…³é”®æ”¹è¿›**ï¼Œç¡®ä¿å®æ–½æ—¶ï¼š

- âœ… run_id/span_id ä¸ä¼šä¹±ç”Ÿæˆ
- âœ… status ä¸ä¼šä¹±è¿ç§»
- âœ… heartbeat ä¸ä¼šè¯¯åˆ¤ stuck
- âœ… artifacts ä¸ä¼šè·¨æœºå™¨å¤±æ•ˆ
- âœ… executor_host å¯ä»¥èšåˆ
- âœ… reason_code å¯ä»¥åˆ†ç±»
- âœ… GC ä¸ä¼šæ–­å¼•ç”¨
- âœ… API å®‰å…¨å¯æ§

**ç°åœ¨å¯ä»¥ç›´æ¥å¼€å·¥äº†ï¼**
