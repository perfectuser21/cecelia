# PRD: Cecelia Executor 任务完成后自动清理 Worktree

## 背景

当前 Cecelia 派发无头任务时，使用 worktree 创建独立工作目录：

```
/home/xx/perfect21/cecelia/core-wt-<uuid>/
```

**问题**：任务完成后，worktree 和分支都没有清理，导致：
- 积累 260+ 个本地废弃分支
- worktree 目录占用磁盘空间
- `git worktree list` 一堆遗留

## 目标

Cecelia 无头任务完成（`status = 'completed'` 或 `'failed'`）后，自动清理：
1. 删除 worktree 目录
2. 删除本地 cp-* 分支
3. 删除远端 cp-* 分支（如果存在）

## 功能需求

### 清理触发点

在 `executor.js` 的任务完成回调中触发清理：

```javascript
// POST /api/brain/execution-callback 处理完成/失败时
if (status === 'completed' || status === 'failed') {
  await cleanupWorktree(task);
}
```

### 清理逻辑

1. **检测 worktree**：
   - 从任务记录获取分支名（`cp-*`）
   - 通过 `git worktree list` 检测是否存在关联 worktree

2. **删除 worktree**：
   - 检查 worktree 目录是否有未提交改动
   - 无改动 → `git worktree remove --force`
   - 有改动 → 记录警告，跳过（防止丢失工作）

3. **删除本地分支**：
   - `git branch -D <cp-branch>`

4. **删除远端分支**（可选）：
   - `git push origin --delete <cp-branch>`
   - 失败不阻塞（可能已被 GitHub 自动删除）

### 安全边界

- **只清理 cp-* 分支** — 其他分支不碰
- **有未提交改动时跳过** — 防止丢失工作
- **清理失败不影响任务状态** — 只记录警告
- **只清理本仓库 worktree** — 不碰其他 repo

## 实现方案

### 新增函数

在 `executor.js` 增加：

```javascript
/**
 * 清理 worktree 和分支（任务完成后）
 */
async function cleanupWorktree(task) {
  const branchName = task.branch; // 假设 task 有 branch 字段

  if (!branchName || !branchName.startsWith('cp-')) {
    return; // 只清理 cp-* 分支
  }

  try {
    // 1. 检测 worktree
    const worktreePath = await getWorktreePath(branchName);
    if (!worktreePath) {
      console.log(`[cleanup] No worktree for ${branchName}`);
      return;
    }

    // 2. 检查未提交改动
    const hasUncommitted = await hasUncommittedChanges(worktreePath);
    if (hasUncommitted) {
      console.warn(`[cleanup] Worktree ${worktreePath} has uncommitted changes, skipping`);
      return;
    }

    // 3. 删除 worktree
    execSync(`git worktree remove "${worktreePath}" --force`, { encoding: 'utf-8' });
    console.log(`[cleanup] Removed worktree: ${worktreePath}`);

    // 4. 删除本地分支
    execSync(`git branch -D "${branchName}"`, { encoding: 'utf-8' });
    console.log(`[cleanup] Deleted local branch: ${branchName}`);

    // 5. 删除远端分支（忽略失败）
    try {
      execSync(`git push origin --delete "${branchName}"`, { encoding: 'utf-8' });
      console.log(`[cleanup] Deleted remote branch: ${branchName}`);
    } catch {
      // 远端可能已删除，忽略
    }
  } catch (err) {
    console.error(`[cleanup] Failed to cleanup ${branchName}:`, err.message);
  }
}

function getWorktreePath(branchName) {
  try {
    const output = execSync('git worktree list', { encoding: 'utf-8' });
    const lines = output.split('\n');
    for (const line of lines) {
      if (line.includes(`[${branchName}]`)) {
        return line.split(/\s+/)[0];
      }
    }
    return null;
  } catch {
    return null;
  }
}

function hasUncommittedChanges(worktreePath) {
  try {
    const output = execSync(`git -C "${worktreePath}" status --porcelain`, { encoding: 'utf-8' });
    return output.trim().length > 0;
  } catch {
    return false;
  }
}
```

### 调用点

在 `POST /api/brain/execution-callback` 中，任务完成时调用：

```javascript
if (status === 'completed' || status === 'failed') {
  // 异步清理，不阻塞响应
  cleanupWorktree(task).catch(err => {
    console.error('[cleanup] Background cleanup failed:', err);
  });
}
```

## 验收标准

- [ ] 无头任务完成后，worktree 自动删除
- [ ] 本地 cp-* 分支自动删除
- [ ] 远端 cp-* 分支自动删除（如果存在）
- [ ] worktree 有未提交改动时跳过清理，记录警告
- [ ] 清理失败不影响任务状态
- [ ] 手动触发任务完成回调，验证清理生效

## 非功能需求

- 清理逻辑在后台异步执行，不阻塞 API 响应
- 清理失败只记录日志，不抛异常
- 只清理本仓库 worktree，不影响其他 repo
