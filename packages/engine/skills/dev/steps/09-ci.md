# Step 9: CI 监控

> 等待 CI 通过，**不在此处合并 PR**
> CI 通过后先执行 Step 10（写 LEARNINGS → push 到功能分支），再回来合并
> **Stop Hook 控制：CI 未通过或 PR 未合并时阻止会话结束（exit 2）**

**Task Checkpoint**: `TaskUpdate({ taskId: "9", status: "in_progress" })`

---

## 流程

```
PR 创建 → 等待 CI → CI 失败？修复 → CI 通过 → Step 10 写 LEARNINGS → 合并 PR → 完成
                          ↑                              ↓                         ↓
                    Stop Hook exit 2           push LEARNINGS 到功能分支    Stop Hook exit 0
                    （继续执行）               （PR 自动包含 LEARNINGS）     （允许结束）
```

---

## 9.1 检查 CI 状态

```bash
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)

# 等待 CI 启动
sleep 30

# 查询 CI 状态
RUN_INFO=$(gh run list --branch "$BRANCH_NAME" --limit 1 --json status,conclusion,databaseId)
CI_STATUS=$(echo "$RUN_INFO" | jq -r '.[0].status')
CI_CONCLUSION=$(echo "$RUN_INFO" | jq -r '.[0].conclusion')

echo "CI 状态: $CI_STATUS"
echo "CI 结论: $CI_CONCLUSION"
```

---

## 9.2 CI 状态处理

| CI 状态 | 动作 |
|---------|------|
| queued / in_progress | 等待，继续检查 |
| failure | 查看日志，修复代码，push |
| success | 继续合并 PR |

### CI 失败修复

```bash
# 获取失败日志
RUN_ID=$(echo "$RUN_INFO" | jq -r '.[0].databaseId')
FAIL_LOG=$(gh run view "$RUN_ID" --log-failed 2>&1 | head -50)
echo "$FAIL_LOG"

# ⚠️ 必须立即记录 incident（在分析和修复之前）
INCIDENT_FILE=".dev-incident-log.json"
FAILED_CHECKS=$(gh run view "$RUN_ID" --json jobs -q '[.jobs[] | select(.conclusion == "failure") | .name] | join(", ")' 2>/dev/null || echo "unknown")
ENTRY=$(jq -n \
    --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    --arg checks "$FAILED_CHECKS" \
    --arg log "$(echo "$FAIL_LOG" | head -20)" \
    '{timestamp: $ts, step: "9-ci", type: "ci_failure", description: ("CI 失败: " + $checks), error: $log, resolution: ""}')
if [[ -f "$INCIDENT_FILE" ]]; then
    jq --argjson e "$ENTRY" '. += [$e]' "$INCIDENT_FILE" > /tmp/incident_tmp.json && mv /tmp/incident_tmp.json "$INCIDENT_FILE"
else
    jq -n --argjson e "$ENTRY" '[$e]' > "$INCIDENT_FILE"
fi
echo "📝 CI 失败已记录到 .dev-incident-log.json"

# 分析失败原因并修复代码
# ...

# 提交修复
git add -A
git commit -m "fix: CI 失败修复

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"

git push origin HEAD

# ⚠️ 修复完成后，更新刚才记录的 incident 的 resolution 字段
# （用 jq 找到最后一条 step=9-ci 的记录，补填 resolution）
RESOLUTION="修复说明（在此填写实际修复内容）"
jq --arg res "$RESOLUTION" '
    (to_entries | reverse | map(select(.value.step == "9-ci" and .value.resolution == "")) | first).key as $idx
    | .[$idx].resolution = $res
' "$INCIDENT_FILE" > /tmp/incident_tmp.json && mv /tmp/incident_tmp.json "$INCIDENT_FILE"
```

**修复后继续等待 CI**，Stop Hook 会在会话尝试结束时检查条件。

---

## 9.3 CI 通过后 → 先执行 Step 10

**⚠️ 重要：CI 通过后不立刻合并 PR**

原因：需要在功能分支上写 LEARNINGS.md 并 push，让 PR 自动包含 LEARNINGS 变更。
合并 PR 的动作移到 **Step 10（Learning）** 的最后执行。

```bash
echo "✅ CI 通过！"
echo "→ 执行 Step 10 (Learning)：写 LEARNINGS → push 到功能分支 → 合并 PR"
echo ""
echo "这样做的好处："
echo "  1. LEARNINGS.md 包含在同一个 PR 中（有 CI 历史可追溯）"
echo "  2. 不需要另开单独的 docs PR"
echo "  3. 合并后 LEARNINGS 直接进入 base branch"
```

**继续 → Step 10 (Learning)**

---

## 9.4 合并 PR（Step 10 完成后执行）

**Step 10 完成后，回到此处合并 PR**：

```bash
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --state open --json number -q '.[0].number')

echo "📋 PR #$PR_NUMBER 包含代码变更 + LEARNINGS.md"
gh pr merge "$PR_NUMBER" --squash --delete-branch

echo "✅ PR #$PR_NUMBER 已合并（包含 LEARNINGS）"
```

---

## 9.5 Stop Hook 完成条件

Stop Hook 检查以下条件决定是否允许会话结束：

| 条件 | 状态 | Stop Hook 行为 |
|------|------|---------------|
| PR 未创建 | ❌ | exit 2（继续创建 PR）|
| CI 失败 | ❌ | exit 2（继续修复）|
| CI 进行中 | ⏳ | exit 2（继续等待）|
| CI 通过但未合并 | ❌ | exit 2（继续合并）|
| **PR 已合并** | ✅ | exit 0（完成！）|

**只有 PR 合并后，Stop Hook 才允许会话结束。**

---

## 禁止行为

- ❌ CI 失败后停止不管
- ❌ PR 创建后就结束
- ❌ 等待用户手动处理

## 正确行为

- ✅ CI 失败 → 查看日志 → 修复代码 → push → 继续等待
- ✅ CI 通过 → 合并 PR
- ✅ PR 合并 → 继续 Step 10/11

---

## 完成后

**CI 通过后立刻执行 Step 10（不标记 Step 9 完成，PR 还未合并）**

Step 9 的完成标记在 Step 10 的合并步骤之后：

```bash
# 在 Step 10 合并 PR 后执行：
sed -i 's/^step_9_ci: pending/step_9_ci: done/' .dev-mode
echo "✅ Step 9 完成标记已写入 .dev-mode"
```

**Task Checkpoint**: `TaskUpdate({ taskId: "9", status: "completed" })` ← Step 10 合并后执行

**继续 → Step 10 (Learning)**

写 LEARNINGS.md → push 到功能分支 → 合并 PR（PR 自动包含 LEARNINGS）
