# PRD: Brain PR Plans 调度集成

## 背景

当前 Brain 的 task dispatcher 只支持二层任务拆解（Goal → Tasks），无法处理三层拆解架构（Objective → KR → Initiative → PR Plans → Tasks）。PR #211 已经完成 PR Plans API（CRUD + 依赖查询），PR #2（cecelia/engine）已经完成 OKR 工具集成，现在需要让 Brain 的调度系统支持 PR Plans。

## 目标

让 Brain 能够：
1. **读取 Initiative 的 PR Plans**：从数据库查询某个 Initiative 的所有 PR Plans
2. **依赖感知调度**：按 `depends_on` 字段顺序派发 PR Plans
3. **状态追踪**：检测 PR Plan 完成状态（所有 Tasks 完成 = PR Plan 完成）
4. **自动派发**：当一个 PR Plan 完成时，自动派发下一个可执行的 PR Plan

## 数据模型回顾

### pr_plans 表（已存在，migration 021）

```sql
CREATE TABLE IF NOT EXISTS pr_plans (
    id TEXT PRIMARY KEY,
    initiative_id TEXT NOT NULL REFERENCES goals(id) ON DELETE CASCADE,
    project_id TEXT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    dod JSONB NOT NULL,
    files JSONB NOT NULL,
    sequence INTEGER NOT NULL,
    depends_on JSONB DEFAULT '[]'::jsonb,
    complexity TEXT CHECK (complexity IN ('low', 'medium', 'high')),
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'blocked')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### tasks 表（已扩展）

```sql
ALTER TABLE tasks ADD COLUMN pr_plan_id TEXT REFERENCES pr_plans(id) ON DELETE CASCADE;
```

## 需要修改的文件

### 1. brain/src/planner.js

**新增函数：`getNextPrPlan(initiativeId)`**

```javascript
/**
 * 获取 Initiative 的下一个可执行 PR Plan
 * @param {string} initiativeId - Initiative ID
 * @returns {Object|null} - PR Plan 对象或 null
 */
export async function getNextPrPlan(initiativeId) {
  // 1. 查询该 Initiative 的所有 PR Plans
  // 2. 过滤出 status='pending' 的 PR Plans
  // 3. 检查每个 PR Plan 的依赖是否已完成
  // 4. 返回第一个依赖已满足的 PR Plan（按 sequence 排序）
}
```

**修改函数：`planNextTask()`**

```javascript
// 在选择 Task 前，先检查是否有 Initiative 需要调度
// 伪代码：
async function planNextTask() {
  // 1. 查询所有 status='in_progress' 的 Initiatives
  for (const initiative of initiatives) {
    const nextPrPlan = await getNextPrPlan(initiative.id);
    if (nextPrPlan) {
      // 创建 Task 关联到这个 PR Plan
      // 使用 PR Plan 的 dod 作为 Task 的 description
      // 设置 pr_plan_id
      return createdTask;
    }
  }

  // 2. 如果没有 Initiative，继续原有逻辑（KR → Task）
  // ...原有代码
}
```

### 2. brain/src/db/pr-plans-queries.js（可能需要新增）

```javascript
/**
 * 查询 Initiative 的所有 PR Plans
 */
export async function getPrPlansByInitiative(client, initiativeId) {
  const result = await client.query(
    `SELECT * FROM pr_plans
     WHERE initiative_id = $1
     ORDER BY sequence ASC`,
    [initiativeId]
  );
  return result.rows;
}

/**
 * 检查 PR Plan 是否完成（所有 Tasks 完成）
 */
export async function isPrPlanCompleted(client, prPlanId) {
  const result = await client.query(
    `SELECT COUNT(*) as total,
            SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed
     FROM tasks
     WHERE pr_plan_id = $1`,
    [prPlanId]
  );
  const { total, completed } = result.rows[0];
  return total > 0 && total === completed;
}

/**
 * 更新 PR Plan 状态
 */
export async function updatePrPlanStatus(client, prPlanId, status) {
  await client.query(
    `UPDATE pr_plans
     SET status = $1, updated_at = NOW()
     WHERE id = $2`,
    [status, prPlanId]
  );
}
```

### 3. brain/src/tick.js

**修改：在 tick 时检查 PR Plans 完成状态**

```javascript
// 在 tick 循环中，检查是否有 PR Plans 已完成
async function checkPrPlansCompletion() {
  const inProgressPrPlans = await client.query(
    `SELECT * FROM pr_plans WHERE status = 'in_progress'`
  );

  for (const prPlan of inProgressPrPlans.rows) {
    if (await isPrPlanCompleted(client, prPlan.id)) {
      await updatePrPlanStatus(client, prPlan.id, 'completed');
      console.log(`✅ PR Plan completed: ${prPlan.title}`);
    }
  }
}
```

## 依赖处理逻辑

**核心算法**：拓扑排序 + 依赖检查

```javascript
function canExecutePrPlan(prPlan, allPrPlans) {
  // 1. 如果 depends_on 为空，可以执行
  if (!prPlan.depends_on || prPlan.depends_on.length === 0) {
    return true;
  }

  // 2. 检查所有依赖的 PR Plans 是否都已完成
  for (const depSeq of prPlan.depends_on) {
    const depPrPlan = allPrPlans.find(p => p.sequence === depSeq);
    if (!depPrPlan || depPrPlan.status !== 'completed') {
      return false; // 有依赖未完成
    }
  }

  return true; // 所有依赖已满足
}
```

## 测试计划

### 单元测试（新增）

**brain/src/__tests__/pr-plans-dispatch.test.js**

```javascript
describe('PR Plans Dispatch', () => {
  test('getNextPrPlan: 返回第一个无依赖的 PR Plan', async () => {
    // Setup: 创建 Initiative + 3 个 PR Plans（无依赖）
    // Assert: 返回 sequence=1 的 PR Plan
  });

  test('getNextPrPlan: 跳过有未完成依赖的 PR Plan', async () => {
    // Setup: PR Plan 1 (completed), PR Plan 2 (depends_on: [1]), PR Plan 3 (pending)
    // Assert: 返回 PR Plan 2
  });

  test('isPrPlanCompleted: 所有 Tasks 完成时返回 true', async () => {
    // Setup: PR Plan + 3 个 Tasks（all completed）
    // Assert: true
  });

  test('isPrPlanCompleted: 有 Task 未完成时返回 false', async () => {
    // Setup: PR Plan + 3 个 Tasks（2 completed, 1 pending）
    // Assert: false
  });
});
```

### 集成测试（Golden Path）

```bash
# 1. 创建 Objective → KR → Initiative
curl -X POST localhost:5221/api/brain/goals \
  -d '{"title":"Test Objective","type":"objective"}'

# 2. 创建 3 个 PR Plans（带依赖）
# PR Plan 1: sequence=1, depends_on=[]
# PR Plan 2: sequence=2, depends_on=[1]
# PR Plan 3: sequence=3, depends_on=[2]

# 3. 触发 tick，验证只派发 PR Plan 1 的 Task
curl -X POST localhost:5221/api/brain/tick

# 4. 完成 PR Plan 1 的 Task，触发 tick
# 验证 PR Plan 1 状态更新为 'completed'
# 验证 PR Plan 2 的 Task 被派发

# 5. 重复直到所有 PR Plans 完成
```

## 验收标准（DoD）

### 功能完整性

- [ ] **F1**: `getNextPrPlan()` 能正确返回下一个可执行的 PR Plan
- [ ] **F2**: `isPrPlanCompleted()` 能准确判断 PR Plan 是否完成
- [ ] **F3**: `updatePrPlanStatus()` 能更新 PR Plan 状态到数据库
- [ ] **F4**: `planNextTask()` 优先调度 Initiative 的 PR Plans
- [ ] **F5**: tick 循环自动检查 PR Plans 完成状态并更新

### 依赖处理

- [ ] **D1**: 无依赖的 PR Plan 立即可执行
- [ ] **D2**: 有依赖的 PR Plan 等待依赖完成后才执行
- [ ] **D3**: 多个无依赖的 PR Plans 按 sequence 顺序执行
- [ ] **D4**: 循环依赖检测（在 OKR 工具已实现，Brain 不需要重复）

### 测试覆盖

- [ ] **T1**: `pr-plans-dispatch.test.js` 包含至少 4 个单元测试
- [ ] **T2**: Golden Path 集成测试通过
- [ ] **T3**: 边界情况测试：空 Initiative、无 PR Plans、全部完成

### 文档

- [ ] **Doc1**: 更新 DEFINITION.md 添加 PR Plans 调度说明
- [ ] **Doc2**: 更新 API 文档（如果有新增端点）
- [ ] **Doc3**: 添加 PR Plans 调度流程图到 docs/

### CI/CD

- [ ] **CI1**: Version Check 通过
- [ ] **CI2**: Facts Consistency 通过
- [ ] **CI3**: Brain (Node.js) 测试全部通过
- [ ] **CI4**: Semantic Brain (Python) 测试全部通过

## 风险与限制

### 风险

1. **性能风险**：如果 Initiative 有大量 PR Plans，查询可能较慢
   - **缓解**：添加索引 `CREATE INDEX idx_pr_plans_initiative ON pr_plans(initiative_id, status, sequence)`

2. **并发风险**：多个 tick 同时更新 PR Plan 状态
   - **缓解**：使用事务锁 `SELECT ... FOR UPDATE`

3. **死锁风险**：循环依赖导致永远无法派发
   - **缓解**：OKR 工具已经有循环依赖检测，Brain 信任输入数据

### 限制

1. **不支持动态依赖**：依赖关系在创建时固定，不能运行时修改
2. **不支持部分依赖**：依赖必须全部完成，不支持"任一依赖完成"逻辑
3. **不支持优先级调度**：严格按 sequence 顺序，不考虑 PR Plan 优先级

## 交付物

### 代码

- [ ] `brain/src/planner.js` - 新增/修改函数
- [ ] `brain/src/db/pr-plans-queries.js` - 新增查询函数
- [ ] `brain/src/tick.js` - 添加 PR Plans 完成检查
- [ ] `brain/src/__tests__/pr-plans-dispatch.test.js` - 单元测试

### 文档

- [ ] `DEFINITION.md` - 更新架构说明
- [ ] `docs/PR-PLANS-DISPATCH.md` - 调度流程文档

### 数据库

- [ ] 确认 migration 021 已应用（pr_plans 表存在）
- [ ] 确认 tasks.pr_plan_id 字段存在

## 时间估算

- **编码**：4-6 小时
- **测试**：2-3 小时
- **文档**：1-2 小时
- **总计**：7-11 小时

## 后续工作（PR #4+）

1. **PR Plans 优先级调度**：支持高优先级 PR Plan 插队
2. **动态依赖调整**：允许运行时修改依赖关系
3. **部分依赖支持**：支持"任一依赖完成"或"至少 N 个依赖完成"
4. **PR Plans 回滚**：支持撤销已完成的 PR Plan
5. **可视化仪表板**：前端展示 PR Plans DAG（有向无环图）

---

**版本**: 1.0.0
**创建日期**: 2026-02-10
**作者**: Claude Sonnet 4.5 + Caramel (dev agent)
