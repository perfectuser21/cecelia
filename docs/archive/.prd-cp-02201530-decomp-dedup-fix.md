# PRD: 修复 decomp-checker dedup 窗口导致队列永久停跑

## 问题描述

`ensureTaskInventory()` 调用 `hasExistingDecompositionTaskByProject()` 时，
该函数会将 24 小时内 completed 的 decomp 任务也视为"已存在"，导致：

1. decomp 任务 completed（拆解出若干 tasks）
2. 拆解出的 tasks 全部 completed/canceled
3. 队列清空（queued=0 < LOW_WATERMARK=2）
4. 但 dedup 检查找到 "24h 内有 completed decomp 任务" → 返回 true → 跳过补货
5. 下次 tick 仍然 skip → 队列永远不被补货 → 系统停跑

## 根本原因

`hasExistingDecompositionTaskByProject()` 的 status 过滤包含：
```
status IN ('queued', 'in_progress', 'canceled', 'cancelled')
OR (status = 'completed' AND completed_at > NOW() - INTERVAL '24 hours')
```

这个设计原意是防止快速重复创建 decomp 任务（decomp 刚完成、任务还没来得及跑），
但没有考虑"decomp 完成 + 产出的任务也全部完成"这种场景。

## 修复方案

在 `ensureTaskInventory()` 中，调用专用的轻量版检查函数，
只检查 `queued/in_progress` 状态，不检查 `completed`：

```javascript
async function hasActiveDecompositionTaskByProject(projectId, level) {
  // 只查 queued/in_progress，不包含 completed
  // 用于 inventory replenishment 路径
  const result = await pool.query(`
    SELECT id FROM tasks
    WHERE project_id = $1
      AND (payload->>'decomposition' IN ('true', 'continue') OR title LIKE '%拆解%')
      AND payload->>'level' = $2
      AND status IN ('queued', 'in_progress')
    LIMIT 1
  `, [projectId, level]);
  return result.rows.length > 0;
}
```

`ensureTaskInventory()` 中将第 3 步改为调用 `hasActiveDecompositionTaskByProject()`。

原 `hasExistingDecompositionTaskByProject()` 保留不变（其他 Check 如 Check 6 仍使用它）。

## 验收条件

1. 新函数 `hasActiveDecompositionTaskByProject()` 已添加
2. `ensureTaskInventory()` 使用新函数
3. 新增回归测试：decomp 任务 completed 且产出 tasks 全部 completed → 下次调用应返回 false（允许补货）
4. 旧函数 `hasExistingDecompositionTaskByProject()` 行为不变（回归测试覆盖）
5. DevGate 通过（facts-check + version-sync）
6. 全量测试通过
