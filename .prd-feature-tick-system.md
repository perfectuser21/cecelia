# PRD: Feature Tick 循环系统

## 背景

实现"一个大脑管两边"架构，支持 Single Task 和 Feature（边做边拆）两种执行模式。

## 目标

1. 更新数据库 Schema，支持任务分层
2. 实现 Feature Tick 循环机制
3. 实现任务类型识别和分流
4. 实现防串线机制

## 架构

```
US VPS (大脑):
├── PostgreSQL (主库)
├── Cecelia 大脑 (Opus)
├── 秋米 (Opus) - 唯一拆解源
├── Caramel (Sonnet) - dev
└── /review (Sonnet)

HK VPS (执行):
├── 部门主管 (MiniMax)
├── N8N 工作流
└── 数据处理 (MiniMax)
```

## 数据库 Schema 变更

### 1. features 表（新建）

```sql
CREATE TABLE features (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- 基本信息
  title TEXT NOT NULL,
  description TEXT,
  prd TEXT,                       -- 大 PRD

  -- 关联
  goal_id UUID REFERENCES goals(id),
  project_id UUID REFERENCES projects(id),

  -- 状态机
  status TEXT NOT NULL DEFAULT 'planning',
  -- planning → task_created → task_running → task_completed → evaluating → completed

  -- 防串线
  active_task_id UUID,            -- 当前活跃的 Task（状态锁）
  current_pr_number INTEGER DEFAULT 0,

  -- 元数据
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);
```

### 2. tasks 表（修改）

```sql
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS execution_mode TEXT DEFAULT 'single';
-- single | feature_task | recurring

ALTER TABLE tasks ADD COLUMN IF NOT EXISTS task_type TEXT;
-- dev | automation | qa | audit | research | content | data
-- 业务语义，由秋米标记

ALTER TABLE tasks ADD COLUMN IF NOT EXISTS execution_profile TEXT DEFAULT 'US_CLAUDE_SONNET';
-- 执行配置，决定如何路由任务
-- US_CLAUDE_OPUS | US_CLAUDE_SONNET | HK_MINIMAX | HK_N8N | LOCAL_BROWSER | LOCAL_N8N

ALTER TABLE tasks ADD COLUMN IF NOT EXISTS feature_id UUID REFERENCES features(id);

ALTER TABLE tasks ADD COLUMN IF NOT EXISTS artifact_ref TEXT;
-- 产物引用（PR URL、日志路径等）

ALTER TABLE tasks ADD COLUMN IF NOT EXISTS summary TEXT;
-- 结果摘要（回大脑用）

ALTER TABLE tasks ADD COLUMN IF NOT EXISTS quality_gate TEXT;
-- pass | fail | pending

ALTER TABLE tasks ADD COLUMN IF NOT EXISTS escalation_level TEXT;
-- none | warning | critical
```

### 2.1 execution_profiles 表（新建）

```sql
CREATE TABLE execution_profiles (
  name TEXT PRIMARY KEY,              -- US_CLAUDE_SONNET
  use_llm BOOLEAN DEFAULT TRUE,
  llm_provider TEXT,                  -- anthropic | minimax | openai
  llm_model TEXT,                     -- opus | sonnet | abab6.5
  runtime_location TEXT NOT NULL,     -- us | hk | local
  executor_kind TEXT NOT NULL,        -- claude_code | api_call | n8n_workflow | browser_automation
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 预置 Profiles
-- 注意：HK_MINIMAX 也是 claude_code，MiniMax 已封装到 Claude Code
INSERT INTO execution_profiles (name, use_llm, llm_provider, llm_model, runtime_location, executor_kind) VALUES
('US_CLAUDE_OPUS', true, 'anthropic', 'opus', 'us', 'claude_code'),
('US_CLAUDE_SONNET', true, 'anthropic', 'sonnet', 'us', 'claude_code'),
('HK_MINIMAX', true, 'minimax', 'abab6.5', 'hk', 'claude_code'),
('HK_N8N', false, NULL, NULL, 'hk', 'n8n_workflow'),
('LOCAL_BROWSER', false, NULL, NULL, 'local', 'browser_automation'),
('LOCAL_N8N', false, NULL, NULL, 'local', 'n8n_workflow');
```

### 3. recurring_tasks 表（新建）

```sql
CREATE TABLE recurring_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  title TEXT NOT NULL,
  description TEXT,

  task_type TEXT NOT NULL,        -- dev | automation | data
  location TEXT DEFAULT 'us',

  cron_expression TEXT NOT NULL,  -- "0 9 * * *"
  template JSONB,                 -- 任务模板

  is_active BOOLEAN DEFAULT TRUE,
  last_run_at TIMESTAMPTZ,
  next_run_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

## Feature Tick 逻辑

### feature-tick.js

```javascript
async function featureTick() {
  // 1. 处理 planning 状态的 Features
  const planningFeatures = await db.query(`
    SELECT * FROM features WHERE status = 'planning'
  `);
  for (const feature of planningFeatures) {
    await planFirstTask(feature);
  }

  // 2. 处理 task_completed 状态的 Features
  const completedFeatures = await db.query(`
    SELECT * FROM features WHERE status = 'task_completed'
  `);
  for (const feature of completedFeatures) {
    await evaluateAndPlanNext(feature);
  }
}

async function planFirstTask(feature) {
  // 调用秋米规划第一个 Task
  const task = await callAutumnrice({
    action: 'plan_first_task',
    feature_id: feature.id,
    feature_prd: feature.prd
  });

  // 创建 Task
  await createTask({
    ...task,
    feature_id: feature.id,
    execution_mode: 'feature_task'
  });

  // 更新 Feature 状态
  await updateFeature(feature.id, {
    status: 'task_created',
    active_task_id: task.id
  });
}

async function evaluateAndPlanNext(feature) {
  // 获取已完成的 Tasks
  const completedTasks = await getCompletedTasks(feature.id);

  // 调用秋米评估
  const result = await callAutumnrice({
    action: 'evaluate_and_plan',
    feature_id: feature.id,
    feature_prd: feature.prd,
    completed_tasks: completedTasks
  });

  if (result.feature_completed) {
    // Feature 完成
    await updateFeature(feature.id, {
      status: 'completed',
      completed_at: new Date()
    });
  } else {
    // 规划下一个 Task
    await createTask({
      ...result.next_task,
      feature_id: feature.id,
      execution_mode: 'feature_task'
    });

    await updateFeature(feature.id, {
      status: 'task_created',
      active_task_id: result.next_task.id,
      current_pr_number: feature.current_pr_number + 1
    });
  }
}
```

## 任务分流逻辑

### 识别任务类型

```javascript
function identifyWorkType(input) {
  // Single Task 特征
  const singlePatterns = /修复|fix|改一下|加个|删掉|更新|调整/i;
  if (singlePatterns.test(input)) {
    return 'single';
  }

  // Feature 特征
  const featurePatterns = /实现|做一个|新功能|系统|模块|重构/i;
  if (featurePatterns.test(input)) {
    return 'feature';
  }

  // 默认问秋米
  return 'ask_autumnrice';
}
```

### 按 execution_profile 分流

秋米拆解时已标记 `execution_profile`，Tick 只需根据 profile 路由：

```javascript
// execution_profiles 定义（从数据库加载或硬编码）
const EXECUTION_PROFILES = {
  'US_CLAUDE_OPUS': {
    use_llm: true,
    llm_provider: 'anthropic',
    llm_model: 'opus',
    runtime_location: 'us',
    executor_kind: 'claude_code'
  },
  'US_CLAUDE_SONNET': {
    use_llm: true,
    llm_provider: 'anthropic',
    llm_model: 'sonnet',
    runtime_location: 'us',
    executor_kind: 'claude_code'
  },
  'HK_MINIMAX': {
    use_llm: true,
    llm_provider: 'minimax',
    llm_model: 'abab6.5',
    runtime_location: 'hk',
    executor_kind: 'claude_code'  // MiniMax 已封装到 Claude Code
  },
  'HK_N8N': {
    use_llm: false,
    runtime_location: 'hk',
    executor_kind: 'n8n_workflow'
  },
  'LOCAL_BROWSER': {
    use_llm: false,
    runtime_location: 'local',
    executor_kind: 'browser_automation'
  },
  'LOCAL_N8N': {
    use_llm: false,
    runtime_location: 'local',
    executor_kind: 'n8n_workflow'
  }
};

async function routeTask(task) {
  const profile = EXECUTION_PROFILES[task.execution_profile];
  if (!profile) {
    throw new Error(`Unknown execution_profile: ${task.execution_profile}`);
  }

  switch (profile.runtime_location) {
    case 'us':
      return await dispatchToUS(task, profile);
    case 'hk':
      return await dispatchToHK(task, profile);
    case 'local':
      return await dispatchToLocal(task, profile);
  }
}

async function dispatchToUS(task, profile) {
  if (profile.executor_kind === 'claude_code') {
    // 启动无头 Claude Code
    const skill = getSkillForTaskType(task.task_type);
    const cmd = `nohup claude -p "/${skill} ${task.context}" --model ${profile.llm_model} > /tmp/task-${task.id}.log 2>&1 &`;
    await exec(cmd);
  }
}

async function dispatchToHK(task, profile) {
  if (profile.executor_kind === 'claude_code') {
    // HK 的 Claude Code（MiniMax 已封装）
    const skill = getSkillForTaskType(task.task_type);
    // 通过 SSH 或 Tailscale 在 HK VPS 执行
    const cmd = `ssh hk "nohup claude -p '/${skill} ${task.context}' --model ${profile.llm_model} > /tmp/task-${task.id}.log 2>&1 &"`;
    await exec(cmd);
  } else if (profile.executor_kind === 'n8n_workflow') {
    // 触发 N8N workflow
    await fetch(`http://100.86.118.99:5679/webhook/${task.workflow_id}`, {
      method: 'POST',
      body: JSON.stringify({ task_id: task.id, ...task.params })
    });
  }
}

async function dispatchToLocal(task, profile) {
  if (profile.executor_kind === 'browser_automation') {
    // 通过 Tailscale 调用本地 Mac
    await fetch(`http://100.x.x.x:3000/automate`, {
      method: 'POST',
      body: JSON.stringify(task)
    });
  } else if (profile.executor_kind === 'n8n_workflow') {
    // 触发本地 N8N
    await fetch(`http://100.x.x.x:5679/webhook/${task.workflow_id}`, {
      method: 'POST',
      body: JSON.stringify(task)
    });
  }
}

// task_type → skill 映射（角色使用的 Skill）
function getSkillForTaskType(taskType) {
  const skillMap = {
    'dev': 'dev',           // Caramel 用 /dev
    'automation': 'dev',    // Nobel 用 /dev（没有 /nobel）
    'qa': 'review',         // 小检 用 /review
    'audit': 'review audit' // 小审 用 /review audit
  };
  return skillMap[taskType] || 'dev';
}
```

## 防串线机制

### 1. Task 创建时绑定 feature_id

```javascript
async function createTask(taskData) {
  if (taskData.feature_id) {
    // 检查 Feature 没有其他活跃 Task
    const feature = await getFeature(taskData.feature_id);
    if (feature.active_task_id) {
      throw new Error('Feature already has active task');
    }
  }

  // 创建 Task
  return await db.query(`
    INSERT INTO tasks (title, feature_id, execution_mode, location, ...)
    VALUES ($1, $2, $3, $4, ...)
    RETURNING *
  `, [taskData.title, taskData.feature_id, taskData.execution_mode, taskData.location]);
}
```

### 2. Task 完成时校验

```javascript
async function completeTask(taskId, result) {
  const task = await getTask(taskId);

  if (task.feature_id) {
    const feature = await getFeature(task.feature_id);

    // 校验是当前活跃的 Task
    if (feature.active_task_id !== taskId) {
      throw new Error('Task is not the active task of feature');
    }

    // 更新 Feature 状态
    await updateFeature(task.feature_id, {
      status: 'task_completed',
      active_task_id: null
    });
  }

  // 更新 Task
  await db.query(`
    UPDATE tasks
    SET status = 'completed',
        result = $1,
        summary = $2,
        completed_at = NOW()
    WHERE id = $3
  `, [result.data, result.summary, taskId]);
}
```

## 验收标准

- [ ] features 表创建成功
- [ ] tasks 表字段添加成功（含 task_type, execution_profile）
- [ ] execution_profiles 表创建成功（含预置 profiles）
- [ ] recurring_tasks 表创建成功
- [ ] Feature Tick 能检测 planning 状态并调用秋米
- [ ] Feature Tick 能检测 task_completed 状态并评估
- [ ] 防串线：同一 Feature 同时只能有一个活跃 Task
- [ ] 防串线：Task 完成时校验 feature_id 一致
- [ ] 秋米能正确标记 task_type + execution_profile
- [ ] Tick 按 execution_profile 正确路由到 US/HK/Local

## 文件变更

1. `brain/migrations/003_feature_tick_system.sql` - 数据库迁移
2. `brain/src/execution-profiles.js` - Profile 定义和加载
3. `brain/src/feature-tick.js` - Feature Tick 逻辑
4. `brain/src/task-router.js` - 任务分流逻辑（按 execution_profile）
5. `brain/src/anti-crossing.js` - 防串线检查
6. `brain/src/tick.js` - 集成 Feature Tick

## 三者配合流程

```
Brain 定义 OKR
    ↓ goals 表 status=ready
Tick 检测 ready
    ↓ 调用秋米
秋米执行 /okr Skill
    ↓ 拆解 → Task (含 task_type + execution_profile)
    ↓ tasks 表 status=queued
Tick 检测 queued
    ↓ 读取 execution_profile
    ↓ 路由到对应执行者
执行完成
    ↓ 更新 task status=completed
    ↓ 如果是 Feature Task → 秋米评估是否继续
repo-lead 汇报
    ↓ Brain 评估
```
