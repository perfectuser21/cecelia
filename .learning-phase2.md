# Learning: Phase 2 - Capability Binding Implementation

## 成功经验

### 1. 分阶段实施策略
- **Phase 1 (Core)**: 先建立数据基础 (capabilities 表 + Brain API)
- **Phase 2 (Engine)**: 再升级工具使用新数据
- **优势**: 降低复杂度，每个阶段职责清晰

### 2. Fail Open 设计模式
- **问题**: Brain API 可能不可用
- **解决**: `check_capability_exists()` 返回 tuple `(exists, brain_available)`
- **好处**:
  - Brain 不可用时不阻塞验证
  - 给出明确的警告信息
  - 区分"不存在"和"无法验证"

### 3. 向后兼容保证
- validate-okr.py 同时支持：
  - 新格式: `initiatives[]` (Phase 2)
  - 旧格式: `features[]`, `initiative + pr_plans` (Phase 1)
- **原则**: 新功能不破坏旧流程

### 4. 测试文件命名规范
- `.test-*.json`: 测试数据文件
- `.test-summary.md`: 测试结果文档
- **好处**: `.gitignore` 统一管理，CI 不会误用

## 踩坑记录

### 1. CI 版本同步检查
**问题**: 更新 package.json 后忘记同步其他版本文件

**教训**: engine 仓库有5个版本文件需要同步
- package.json (基准)
- package-lock.json
- VERSION
- .hook-core-version
- regression-contract.yaml

**解决**: `npm version` 会自动同步 package-lock.json，其他需手动

### 2. Config Audit 严格性
**问题**: 修改 regression-contract.yaml 触发 config-audit，要求 PR title 包含 [CONFIG] 标记

**教训**: engine 对配置变更有严格把关
- regression-contract.yaml
- feature-registry.yml
- hooks/
- skills/

**解决**: PR title 加上 [CONFIG] 标记

### 3. Contract Drift Check
**问题**: 修改 feature-registry.yml 后没有重新生成派生视图

**教训**: feature-registry.yml 是"单一事实源"，docs/paths/ 是自动生成的
- 修改 registry 必须运行 `bash scripts/generate-path-views.sh`
- CI 会检查一致性

**解决**: 自动生成 → 提交

### 4. Brain API 依赖
**问题**: 测试时 Brain API 没有 Phase 1 endpoints

**教训**:
- Phase 2 依赖 Phase 1 已部署
- 应在 PRD 中明确标注依赖
- 测试环境与生产环境不一致

**解决**:
- 文档中注明依赖
- 测试时使用 fail open 机制
- 等待 Phase 1 部署后再验证完整性

## 代码质量改进

### 1. Python 错误处理
```python
# Before: 只返回 bool
def check_capability_exists(cap_id):
    try:
        resp = requests.get(...)
        return resp.status_code == 200
    except:
        return False

# After: 返回 tuple 区分状态
def check_capability_exists(cap_id):
    try:
        resp = requests.get(...)
        return (resp.status_code == 200, True)  # (exists, brain_available)
    except:
        return (False, False)  # Brain unavailable
```

### 2. Bash 字段提取
```bash
# NULL 值处理
capability_id=$(jq -r '.capability_id // null' output.json)
from_stage=$(jq -r '.from_stage // null' output.json)

# 空字符串 fallback
evidence_required=$(jq -r '.evidence_required // ""' output.json)
```

## 流程改进建议

### 1. 跨仓库依赖管理
**现状**: Phase 1 (Core) 和 Phase 2 (Engine) 分属不同仓库

**建议**:
- 在 PRD 中明确列出依赖的 PR
- 使用 GitHub PR reference: `perfectuser21/cecelia-core#255`
- 部署时检查依赖是否已部署

### 2. CI 失败自动修复
**现状**: 遇到 CI 失败需要手动查看日志 → 修复 → 重新 push

**建议**:
- Version sync check: 可以提供自动修复脚本
- Contract drift: 自动运行 generate-path-views.sh
- Config audit: 自动检测并建议 PR title

### 3. 测试环境一致性
**现状**: 本地测试时 Brain API 可能没有最新 endpoints

**建议**:
- 使用 Docker Compose 统一测试环境
- 或提供 mock Brain API for testing
- 或在 PRD 中明确标注"依赖 Phase 1 deployed"

## 总结

### 完成的工作
✅ validate-okr.py 升级 (7 个 capability 校验)
✅ store-to-database.sh 字段传递
✅ /okr SKILL.md "开工前必问"规则
✅ 向后兼容保证
✅ 测试文件和文档
✅ CI 全部通过
✅ PR 成功合并

### 时间分配
- 编码: 30 min
- 测试: 15 min
- CI 修复: 20 min (3 次迭代)
- 文档: 10 min

### 关键成功因素
1. **分阶段设计** - 降低复杂度
2. **Fail Open** - 提高容错性
3. **向后兼容** - 保护旧流程
4. **充分测试** - 3 个测试场景
5. **详细文档** - PRD/DoD/Testing Summary

### 后续行动
1. ⏳ 等待 Phase 1 部署到生产
2. ⏳ 重新运行测试验证 40/40 分
3. ⏳ 监控第一个使用 capability binding 的 OKR 拆解
