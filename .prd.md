# PRD: Immune System v1 - P1 (Probation + Promotion)

## 背景

P0 已完成免疫系统基础设施：
- ✅ 3 个数据库表（failure_signatures, absorption_policies, policy_evaluations）
- ✅ 8 个核心函数（immune-system.js）
- ✅ Monitor Loop 集成（active policy 优先于 RCA）

**P0 的局限**：策略仓库已就位，但"学习闭环"还未启动：
- 新策略无法自动进入 probation
- Probation 策略不会晋升到 active
- 没有自动禁用机制（误判保护）

## P1 目标

让免疫系统真正"稳步变强"：
1. **Probation 默认 simulate** - 新策略只观察，不执行
2. **Promotion Job** - 自动晋升通过验证的策略
3. **Auto-disable** - 自动禁用误判策略
4. **硬护栏** - 防止规则爆炸（每日晋升上限）

**核心原则**：宁可慢一点晋升，也不让系统"学坏"。

---

## Ticket 1: Probation Simulate + Evaluation 记录强化

### 改动目标

1. Probation 策略命中时**只 simulate，绝不 enforce**
2. Evaluation 记录增强：存储 `would_do` 和 `expected_outcome`
3. Monitor Loop 优先级补充：区分 probation vs active 处理逻辑

### 实现细节

#### 1.1 Monitor Loop 改动（brain/src/monitor-loop.js）

现有逻辑（P0）：
```javascript
// 1. Check active policy
const activePolicy = await findActivePolicy(signature);
if (activePolicy) {
  // Execute policy and record
  await recordPolicyEvaluation({ mode: 'enforce', decision: 'applied' });
  continue; // Skip RCA
}

// 2. Check probation policy (simulate)
const probationPolicy = await findProbationPolicy(signature);
if (probationPolicy) {
  await recordPolicyEvaluation({ mode: 'simulate' });
  // Continue to RCA (don't skip)
}
```

**P1 补充**：Probation 策略需要记录"本来会做什么"：

```javascript
// 2. Check probation policy (simulate only)
const probationPolicy = await findProbationPolicy(signature);
if (probationPolicy) {
  // Parse policy_json to extract intended action
  const intendedAction = parsePolicyAction(probationPolicy.policy_json);

  await recordPolicyEvaluation({
    policy_id: probationPolicy.policy_id,
    run_id: failure.run_id,
    signature,
    mode: 'simulate',
    decision: 'simulated', // New decision type
    details: {
      would_do: intendedAction.type, // e.g., 'requeue', 'skip', 'adjust_params'
      would_apply: intendedAction.params,
      expected_outcome: intendedAction.expected_outcome,
      simulated_at: new Date().toISOString()
    }
  });

  // Continue to RCA (gather real solution for comparison)
}
```

#### 1.2 新增 Helper 函数（brain/src/immune-system.js）

```javascript
/**
 * Parse policy_json to extract intended action
 * @param {Object} policyJson - JSON from absorption_policies.policy_json
 * @returns {Object} { type, params, expected_outcome }
 */
export function parsePolicyAction(policyJson) {
  // Example policy_json structure:
  // {
  //   "action": "requeue",
  //   "params": { "delay_minutes": 30, "priority": "low" },
  //   "expected_outcome": "Task will retry after 30 min with lower priority"
  // }
  return {
    type: policyJson.action || 'unknown',
    params: policyJson.params || {},
    expected_outcome: policyJson.expected_outcome || 'No expected outcome defined'
  };
}
```

#### 1.3 Evaluation 表字段确认

现有 `policy_evaluations` 表已有 `details JSONB` 字段，无需 migration。

P1 使用 `details` 存储：
```json
{
  "would_do": "requeue",
  "would_apply": { "delay_minutes": 30 },
  "expected_outcome": "Task will retry after 30 min",
  "simulated_at": "2026-02-12T10:00:00Z"
}
```

### 验收标准

- [ ] Probation 策略命中时，`mode='simulate'`, `decision='simulated'`
- [ ] Evaluation 的 `details` 包含 `would_do`, `would_apply`, `expected_outcome`
- [ ] Monitor Loop 日志显示 `[Immune] Probation policy simulated: signature=xxx, would_do=requeue`
- [ ] Active 策略仍然 `mode='enforce'`, `decision='applied'`（不影响现有逻辑）

---

## Ticket 2: Promotion Job（10分钟一次）

### 改动目标

1. 创建 Promotion Job（独立定时任务）
2. 实现晋升规则（probation → active）
3. 实现自动禁用（probation/active → disabled）
4. 硬护栏：每日晋升上限 3 条

### 实现细节

#### 2.1 晋升规则（稳健版）

##### Draft → Probation（已在 P0 实现）
- 同 signature 24h 内 ≥ 2 次 OR 7d ≥ 3 次
- 由 Monitor Loop 的 `shouldPromoteToProbation()` 检测
- P1 不改动，保持现有逻辑

##### Probation → Active（P1 新增）
满足**全部**条件：
1. Simulate 命中 ≥ 2 次
2. Verification 通过率 ≥ 90%（pass / (pass + fail) ≥ 0.9）
3. `risk_level = 'low'`
4. 未触发禁用条件

##### Active → Disabled（P1 新增）
满足**任一**条件：
1. Enforce 后 verification fail ≥ 1（首次失败立即禁用）
2. 或连续误判 ≥ 2（decision='failed' 连续 2 次）

##### Probation → Disabled（P1 新增）
满足**任一**条件：
1. Simulate 期间 verification fail ≥ 2
2. 或在 probation 超过 7 天仍未达到晋升标准

#### 2.2 Promotion Job 实现（brain/src/promotion-job.js）

```javascript
import { pool } from './db.js';
import { recordPolicyEvaluation } from './immune-system.js';

// Hard limit: max promotions per day
const MAX_PROMOTIONS_PER_DAY = 3;

/**
 * Run promotion job - promote probation to active, disable failed policies
 */
export async function runPromotionJob() {
  console.log('[PromotionJob] Starting promotion job...');

  try {
    // 1. Check daily promotion limit
    const promotedToday = await countPromotionsToday();
    const remainingSlots = MAX_PROMOTIONS_PER_DAY - promotedToday;

    if (remainingSlots <= 0) {
      console.log('[PromotionJob] Daily promotion limit reached, skipping');
      return { promoted: 0, disabled: 0, reason: 'daily_limit_reached' };
    }

    // 2. Find candidates for promotion (probation → active)
    const candidates = await findPromotionCandidates(remainingSlots);
    console.log(`[PromotionJob] Found ${candidates.length} promotion candidates`);

    // 3. Promote qualifying policies
    let promoted = 0;
    for (const candidate of candidates) {
      const success = await promoteToActive(candidate);
      if (success) promoted++;
    }

    // 4. Find policies to disable
    const toDisable = await findPoliciesToDisable();
    console.log(`[PromotionJob] Found ${toDisable.length} policies to disable`);

    // 5. Disable failed policies
    let disabled = 0;
    for (const policy of toDisable) {
      const success = await disablePolicy(policy);
      if (success) disabled++;
    }

    console.log(`[PromotionJob] Completed: promoted=${promoted}, disabled=${disabled}`);
    return { promoted, disabled };
  } catch (error) {
    console.error('[PromotionJob] Error:', error);
    throw error;
  }
}

/**
 * Count promotions today (for rate limiting)
 */
async function countPromotionsToday() {
  const result = await pool.query(`
    SELECT COUNT(*) as count
    FROM policy_evaluations
    WHERE mode = 'promote'
      AND decision = 'applied'
      AND created_at >= NOW() - INTERVAL '24 hours'
  `);
  return parseInt(result.rows[0]?.count || 0);
}

/**
 * Find probation policies ready for promotion
 */
async function findPromotionCandidates(limit) {
  const result = await pool.query(`
    WITH policy_stats AS (
      SELECT
        pe.policy_id,
        ap.signature,
        ap.risk_level,
        ap.policy_json,
        COUNT(*) FILTER (WHERE pe.mode = 'simulate') as simulate_count,
        COUNT(*) FILTER (WHERE pe.verification_result = 'pass') as pass_count,
        COUNT(*) FILTER (WHERE pe.verification_result = 'fail') as fail_count
      FROM policy_evaluations pe
      JOIN absorption_policies ap ON ap.policy_id = pe.policy_id
      WHERE ap.status = 'probation'
        AND pe.created_at >= NOW() - INTERVAL '7 days'
      GROUP BY pe.policy_id, ap.signature, ap.risk_level, ap.policy_json
    )
    SELECT *
    FROM policy_stats
    WHERE simulate_count >= 2
      AND risk_level = 'low'
      AND (pass_count::float / NULLIF(pass_count + fail_count, 0)) >= 0.9
      AND fail_count < 2  -- Not in disable zone
    ORDER BY simulate_count DESC
    LIMIT $1
  `, [limit]);

  return result.rows;
}

/**
 * Promote policy to active
 */
async function promoteToActive(candidate) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Update policy status
    await client.query(`
      UPDATE absorption_policies
      SET status = 'active',
          updated_at = NOW()
      WHERE policy_id = $1
    `, [candidate.policy_id]);

    // Record promotion event
    await client.query(`
      INSERT INTO policy_evaluations (
        policy_id, signature, mode, decision, details, created_at
      ) VALUES ($1, $2, 'promote', 'applied', $3, NOW())
    `, [
      candidate.policy_id,
      candidate.signature,
      JSON.stringify({
        simulate_count: candidate.simulate_count,
        pass_count: candidate.pass_count,
        fail_count: candidate.fail_count,
        success_rate: candidate.pass_count / (candidate.pass_count + candidate.fail_count),
        promoted_at: new Date().toISOString()
      })
    ]);

    await client.query('COMMIT');
    console.log(`[PromotionJob] Promoted policy ${candidate.policy_id} to active`);
    return true;
  } catch (error) {
    await client.query('ROLLBACK');
    console.error(`[PromotionJob] Failed to promote ${candidate.policy_id}:`, error);
    return false;
  } finally {
    client.release();
  }
}

/**
 * Find policies to disable (probation or active with failures)
 */
async function findPoliciesToDisable() {
  const result = await pool.query(`
    WITH recent_failures AS (
      SELECT
        pe.policy_id,
        ap.status,
        ap.signature,
        COUNT(*) FILTER (WHERE pe.verification_result = 'fail') as fail_count,
        COUNT(*) FILTER (WHERE pe.decision = 'failed') as consecutive_fails,
        MAX(pe.created_at) as last_evaluation,
        MIN(ap.created_at) as policy_created
      FROM policy_evaluations pe
      JOIN absorption_policies ap ON ap.policy_id = pe.policy_id
      WHERE ap.status IN ('probation', 'active')
        AND pe.created_at >= NOW() - INTERVAL '7 days'
      GROUP BY pe.policy_id, ap.status, ap.signature, ap.created_at
    )
    SELECT *
    FROM recent_failures
    WHERE
      -- Active policy: fail once = disable
      (status = 'active' AND fail_count >= 1)
      -- Probation: fail twice = disable
      OR (status = 'probation' AND fail_count >= 2)
      -- Probation stale: 7 days without promotion
      OR (status = 'probation' AND policy_created < NOW() - INTERVAL '7 days')
      -- Consecutive failures
      OR (consecutive_fails >= 2)
  `);

  return result.rows;
}

/**
 * Disable policy
 */
async function disablePolicy(policy) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Update policy status
    await client.query(`
      UPDATE absorption_policies
      SET status = 'disabled',
          updated_at = NOW()
      WHERE policy_id = $1
    `, [policy.policy_id]);

    // Record disable event
    await client.query(`
      INSERT INTO policy_evaluations (
        policy_id, signature, mode, decision, details, created_at
      ) VALUES ($1, $2, 'disable', 'applied', $3, NOW())
    `, [
      policy.policy_id,
      policy.signature,
      JSON.stringify({
        reason: policy.status === 'active' ? 'active_verification_failed' :
                policy.fail_count >= 2 ? 'probation_multiple_failures' :
                'probation_stale',
        fail_count: policy.fail_count,
        consecutive_fails: policy.consecutive_fails,
        disabled_at: new Date().toISOString()
      })
    ]);

    await client.query('COMMIT');
    console.log(`[PromotionJob] Disabled policy ${policy.policy_id} (reason: ${policy.status})`);
    return true;
  } catch (error) {
    await client.query('ROLLBACK');
    console.error(`[PromotionJob] Failed to disable ${policy.policy_id}:`, error);
    return false;
  } finally {
    client.release();
  }
}

/**
 * Start promotion job loop (runs every 10 minutes)
 */
export function startPromotionJobLoop() {
  const INTERVAL_MS = 10 * 60 * 1000; // 10 minutes

  console.log('[PromotionJob] Starting promotion job loop (every 10 min)');

  // Run immediately on startup
  runPromotionJob().catch(err => {
    console.error('[PromotionJob] Initial run failed:', err);
  });

  // Then run every 10 minutes
  setInterval(() => {
    runPromotionJob().catch(err => {
      console.error('[PromotionJob] Scheduled run failed:', err);
    });
  }, INTERVAL_MS);
}
```

#### 2.3 集成到 Server（brain/server.js）

```javascript
import { startPromotionJobLoop } from './src/promotion-job.js';

// ... existing imports and setup ...

// Start promotion job loop
startPromotionJobLoop();
```

#### 2.4 测试（brain/src/__tests__/promotion-job.test.js）

创建测试覆盖：
1. `countPromotionsToday()` - 正确计数
2. `findPromotionCandidates()` - 正确筛选候选（≥2 simulate, ≥90% pass, low risk）
3. `promoteToActive()` - 正确更新状态 + 写 evaluation
4. `findPoliciesToDisable()` - 正确找到失败策略
5. `disablePolicy()` - 正确禁用 + 写 evaluation
6. Daily limit - 达到上限时停止晋升

### 验收标准

- [ ] Promotion Job 每 10 分钟运行一次
- [ ] Probation 策略满足条件时晋升到 active
- [ ] Active 策略 verification fail 一次立即禁用
- [ ] Probation 策略超过 7 天未晋升自动禁用
- [ ] 每日晋升上限 3 条（硬护栏生效）
- [ ] 所有晋升/禁用事件记录到 policy_evaluations
- [ ] 测试覆盖率 ≥ 80%

---

## 非功能需求

### 性能
- Promotion Job 每轮执行时间 < 5 秒（避免阻塞）
- SQL 查询使用索引（policy_id, status, created_at）

### 可观测性
- 每轮 Promotion Job 输出日志：promoted 数量 + disabled 数量
- Monitor Loop 输出 probation simulate 日志
- Dashboard 可查看策略状态分布（draft/probation/active/disabled）

### 安全
- MAX_PROMOTIONS_PER_DAY 硬编码为 3，不可配置（避免误改）
- Disable 条件保守（宁可禁用，不可误判后继续执行）

---

## 测试策略

### 单元测试
- `parsePolicyAction()` - 正确解析各种 policy_json 格式
- `countPromotionsToday()` - 正确计数（跨天边界测试）
- `findPromotionCandidates()` - 正确筛选（边界条件：89% vs 90%）
- `promoteToActive()` - 事务完整性
- `findPoliciesToDisable()` - 各种禁用条件
- `disablePolicy()` - 事务完整性

### 集成测试
- E2E：failure → probation simulate → promotion → active enforce → disable（完整生命周期）

### 手动测试
1. 创建 2 个 probation 策略（1个 low risk, 1个 medium risk）
2. 插入 simulate evaluations（pass_count=2, fail_count=0）
3. 运行 Promotion Job
4. 验证：low risk 晋升，medium risk 保持 probation

---

## 交付清单

### 代码文件
- [ ] `brain/src/immune-system.js` - 新增 `parsePolicyAction()`
- [ ] `brain/src/monitor-loop.js` - 增强 probation simulate 逻辑
- [ ] `brain/src/promotion-job.js` - 完整实现（~200 行）
- [ ] `brain/server.js` - 启动 Promotion Job Loop

### 测试文件
- [ ] `brain/src/__tests__/promotion-job.test.js` - 完整测试套件

### 文档
- [ ] `DEFINITION.md` - 更新免疫系统状态机图
- [ ] `LEARNINGS.md` - 记录 P1 实施经验

### 无需 Migration
- 使用现有表结构，无需新表或字段

---

## 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| Promotion Job 过于频繁晋升 | 策略质量下降 | MAX_PROMOTIONS_PER_DAY = 3 硬限制 |
| Disable 条件过于严格 | 有用策略被误禁 | Probation 允许 2 次失败，Active 1 次失败才禁用 |
| SQL 查询性能问题 | Job 运行超时 | 添加索引 + LIMIT 限制结果集 |
| 策略 JSON 格式不一致 | parsePolicyAction 崩溃 | 增加 try-catch + 默认值 |

---

## 成功指标

1. **LLM 触发率下降** - Active 策略吸收重复失败，Cortex RCA 调用减少
2. **Probation 通过率** - 晋升到 active 的策略 ≥ 70% 长期有效（不被 disable）
3. **Disable 及时性** - 误判策略在 2 次失败内被禁用
4. **系统稳定性** - 每日晋升 ≤ 3 条，策略数量可控增长

---

## 参考

- P0 PR: #217
- 免疫系统设计文档：用户提供的 P1/P2 清单
- 相关模块：`brain/src/immune-system.js`, `brain/src/monitor-loop.js`
