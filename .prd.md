## PRD: 渐进式派发机制（Gradual Ramp-up）

### 背景
当前问题：Tick Loop 在一个 tick 内瞬间派发多个任务（如 6 个），导致系统 CPU/内存过载，Watchdog 被迫 kill 进程,任务失败率高。

真实案例：14:17 瞬间派发 7 个拆解任务 → CPU 负载从 2.0 飙升到 10.58 → 4 个进程被 kill → 任务失败率 40%。

### 目标
实现渐进式派发机制，让并发任务数量逐步增加和减少，避免瞬间过载。

### 核心思路
1. **存储状态**：在 working_memory 存储 current_dispatch_rate（当前每 tick 派发数量）
2. **动态调整**：每个 tick 根据负载调整 current_dispatch_rate
   - 负载低（pressure < 0.5，Alertness = CALM）→ 增加（+1）
   - 负载高（pressure > 0.8）→ 减少（-1）
   - 危险（Alertness >= ALERT）→ 减速或暂停
3. **限制派发数量**：每个 tick 最多派发 current_dispatch_rate 个任务

### 需求

#### 1. 新增函数：getRampedDispatchMax()

在 tick.js 中新增函数，放在 executeTick() 之前：

功能：根据当前负载和历史记录，返回本次 tick 应该派发的任务数量。

逻辑：
- 从 working_memory 读取 dispatch_ramp_state（包含 current_rate）
- 检查当前负载（checkServerResources, getCurrentAlertness）
- 根据负载动态调整 current_rate：
  - Alertness >= ALERT → 减速（-1，最低 0）
  - pressure < 0.5 且 Alertness = CALM → 加速（+1）
  - pressure > 0.8 → 减速（-1，最低 1）
  - 否则保持不变
- 保存新的 current_rate 到 working_memory
- 返回 newRate

#### 2. 修改 executeTick() 中的派发逻辑

在 tick.js line 1141 之后添加：
```
const rampedDispatchMax = await getRampedDispatchMax(effectiveDispatchMax);
```

修改 line 1150 的循环：
```
for (let i = 0; i < rampedDispatchMax; i++) {  // 改为 rampedDispatchMax
```

修改 line 1179 的循环：
```
for (let i = dispatched; i < rampedDispatchMax; i++) {  // 改为 rampedDispatchMax
```

添加日志：
```
console.log(`[tick] Ramped dispatch: ${currentRate} → ${newRate} (pressure: ${pressure}, alertness: ${alertness.levelName})`);
```

### DoD
- [ ] 实现 getRampedDispatchMax() 函数
- [ ] 在 executeTick() 中集成调用
- [ ] 修改两处派发循环使用 rampedDispatchMax
- [ ] 添加日志输出当前派发速率变化
- [ ] 编写测试验证渐进增加逻辑
- [ ] 通过 CI

### 验收标准
1. **渐进增加**：从 0 个任务开始，每次增加 1 个，直到达到稳定状态
2. **自动减速**：负载高时自动减少派发数量
3. **不再瞬间过载**：CPU 负载不会突然从 2.0 跳到 10+
4. **任务成功率提升**：失败率从 40% 降低到 20% 以下

### 预估时间
15-20 分钟
