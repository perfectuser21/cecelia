# Slot Allocation System Design

## 1. Overview

Replace the current flat `MAX_SEATS - INTERACTIVE_RESERVE` model with a three-pool slot system that provides guaranteed capacity for Cecelia's internal work, user headed sessions, and auto-dispatched tasks.

### Current System (Problems)

```
MAX_SEATS = 12 (auto-calculated from hardware)
INTERACTIVE_RESERVE = 2 (just a number subtracted from AUTO_DISPATCH_MAX)
AUTO_DISPATCH_MAX = MAX_SEATS - INTERACTIVE_RESERVE = 10

Problem: "reserve" is not enforced. Auto-dispatch uses all 10 slots,
and if user opens a headed session, it just competes for the same resources.
No detection of headed vs headless. No graceful yield.
```

### New System

```
Total Hardware Capacity: 12 slots (8 cores, 16GB)

Pool A: Cecelia Reserved    = 1 slot  (OKR decomposition, cortex RCA)
Pool B: User Reserved       = 2 slots (headed sessions, team agents)
Pool C: Dynamic Task Pool   = 9 slots (auto-dispatch, pressure-scaled)

Priority: User (B) > Cecelia (A) > Task Pool (C)
```

---

## 2. Slot Categories

### Pool A: Cecelia Reserved (1 slot)

**Purpose**: Guarantee Cecelia can always do internal housekeeping — OKR decomposition (秋米), cortex RCA analysis, and similar Brain-internal work.

**Behavior**:
- 1 slot always reserved for Cecelia's internal tasks
- "Internal task" = tasks with `payload.decomposition` set OR `payload.requires_cortex` set
- This slot is **on-demand reserved**, not pre-occupied: if Cecelia has no internal work, the slot goes to Pool C
- When Cecelia needs it and Pool C is full, Cecelia waits for the next task to finish naturally (no preemption within this pool)

**Detection**: Task identification, not process detection. The dispatch logic already knows which tasks are internal (decomposition/cortex).

### Pool B: User Reserved (2 slots, expandable)

**Purpose**: Guarantee the user can always start headed sessions and team agents.

**Behavior**:
- 2 slots always available for user's headed sessions
- When user opens 1 headed session → system proactively ensures 1 more slot is available
- When user starts team agents (3-4 `claude` processes in quick succession) → system enters "user-priority mode"
- In user-priority mode: stop all new auto-dispatches, let running tasks drain naturally

**Detection**: See Section 4.

### Pool C: Dynamic Task Pool (remaining slots)

**Purpose**: Auto-dispatch queued tasks, scaled by resource pressure.

**Behavior**:
- Base capacity = `TOTAL_CAPACITY - CECELIA_RESERVED - USER_RESERVED` = 12 - 1 - 2 = 9
- Actual available = base capacity minus any slots currently used by Pool A and Pool B
- Further throttled by resource pressure (existing `checkServerResources()` logic)
- Graceful wind-down: when Pool B demand increases, Pool C stops dispatching and lets running tasks finish

---

## 3. Priority Order and Preemption

```
User (Pool B)
  ↓ yields to nobody
  ↓ can trigger "user-priority mode" → freezes Pool C dispatch

Cecelia (Pool A)
  ↓ yields to User (Pool B) — if user needs more slots, Cecelia waits
  ↓ preempts Pool C — if Cecelia needs a slot and only Pool C is available

Task Pool (Pool C)
  ↓ yields to everybody
  ↓ never kills running tasks — just stops dispatching new ones
```

### Preemption Rules

1. **Never kill a running task**. Period. The only exception is the existing watchdog (RSS/CPU hard limits).
2. When slots need to be reclaimed, **stop dispatching** from Pool C.
3. Running Pool C tasks drain naturally (timeout or completion).
4. Pool A (Cecelia internal) tasks also drain naturally — they're typically short (< 5 min).

---

## 4. Headed Session and Team Agent Detection

### 4a. Detecting Headed Sessions

**Headed session** = `claude` process without `-p` flag (interactive mode).

```javascript
// Detection logic (added to getActiveProcessCount or new function)
function detectUserSessions() {
  // Get all claude processes
  const allClaude = execSync(
    'ps -eo pid,args --no-headers | grep -E " claude( |$)" | grep -v grep',
    { encoding: 'utf-8' }
  ).trim().split('\n').filter(Boolean);

  const headed = [];   // claude without -p (user interactive)
  const headless = []; // claude -p (Cecelia dispatched)

  for (const line of allClaude) {
    const parts = line.trim().split(/\s+/);
    const pid = parseInt(parts[0]);
    const args = parts.slice(1).join(' ');

    if (args.includes(' -p ') || args.includes(' -p\n') || args.endsWith(' -p')) {
      headless.push({ pid, args });
    } else {
      headed.push({ pid, args });
    }
  }

  return { headed, headless, total: allClaude.length };
}
```

**Key insight**: `claude -p "/dev ..."` is headless (Cecelia dispatched). Plain `claude` is headed (user interactive).

### 4b. Detecting Team Agents

**Team agents** = multiple headed `claude` processes spawned in quick succession by the user (via Claude Code's team feature).

Detection heuristic:
- If `headed.length >= 3` within a 60-second window → likely team agents
- Simple: just count headed processes. If >=3, enter user-priority mode.

```javascript
function detectUserMode(sessions) {
  const { headed } = sessions;

  if (headed.length >= 3) {
    return 'team';      // User is using team agents (3+)
  } else if (headed.length >= 1) {
    return 'interactive'; // User has 1-2 headed sessions
  }
  return 'absent';       // No user sessions
}
```

We don't need to track spawn timing. The count is sufficient: if 3+ headed `claude` processes exist, the user is clearly using team agents and we should yield.

---

## 5. Slot Allocation Algorithm

### Constants

```javascript
const TOTAL_CAPACITY = MAX_SEATS;        // 12 (from hardware)
const CECELIA_RESERVED = 1;               // Pool A
const USER_RESERVED_BASE = 2;             // Pool B minimum
const USER_PRIORITY_HEADROOM = 2;         // Extra slots to keep free when user is active
```

### Per-Tick Slot Calculation

```javascript
function calculateSlotBudget() {
  const sessions = detectUserSessions();
  const userMode = detectUserMode(sessions);
  const userSlotsUsed = sessions.headed.length;

  // Pool B: user slots used + headroom
  let userBudget;
  if (userMode === 'team') {
    // Team mode: user gets whatever they need, system yields everything
    userBudget = userSlotsUsed + USER_PRIORITY_HEADROOM;
  } else if (userMode === 'interactive') {
    // Interactive: user has 1-2 sessions, keep 1-2 more ready
    userBudget = userSlotsUsed + USER_PRIORITY_HEADROOM;
  } else {
    // Absent: base reservation (in case user appears)
    userBudget = USER_RESERVED_BASE;
  }

  // Pool A: Cecelia internal (1 slot, on-demand)
  const ceceliaNeeded = hasPendingInternalTasks() ? CECELIA_RESERVED : 0;

  // Pool C: remaining for auto-dispatch
  const poolCBudget = Math.max(0, TOTAL_CAPACITY - userBudget - ceceliaNeeded);

  // Further throttle by resource pressure (existing logic)
  const resources = checkServerResources();
  const pressureAdjusted = Math.min(poolCBudget, resources.effectiveSlots);

  return {
    total: TOTAL_CAPACITY,
    user: { budget: userBudget, used: userSlotsUsed, mode: userMode },
    cecelia: { budget: ceceliaNeeded, used: countCeceliaInProgress() },
    taskPool: { budget: pressureAdjusted, used: countAutoDispatchInProgress() },
    pressure: resources.metrics.max_pressure,
  };
}
```

### hasPendingInternalTasks()

```javascript
async function hasPendingInternalTasks() {
  const result = await pool.query(`
    SELECT COUNT(*) FROM tasks
    WHERE status = 'queued'
    AND (payload->>'decomposition' IS NOT NULL
         OR payload->>'requires_cortex' = 'true')
  `);
  return parseInt(result.rows[0].count) > 0;
}
```

### Dispatch Gate (modified dispatchNextTask)

The key change is in `dispatchNextTask()` in `tick.js`:

```javascript
// BEFORE (current):
const effectiveLimit = Math.min(AUTO_DISPATCH_MAX, resources.effectiveSlots);
const activeCount = Math.max(dbActiveCount, processActiveCount);
if (activeCount >= effectiveLimit) { return 'max_concurrent_reached'; }

// AFTER (new):
const budget = calculateSlotBudget();
const autoDispatchActive = countAutoDispatchInProgress();
if (autoDispatchActive >= budget.taskPool.budget) {
  return {
    dispatched: false,
    reason: 'pool_c_full',
    budget: budget
  };
}
```

---

## 6. User-Priority Mode (Graceful Wind-Down)

When the system detects the user is active (`userMode !== 'absent'`), it enters a graduated response:

### Level 1: User Interactive (1-2 headed sessions)

- Keep `USER_PRIORITY_HEADROOM` (2) extra slots free
- Reduce Pool C budget accordingly
- If Pool C budget drops below current running count → **stop dispatching**, let tasks drain
- No urgency — tasks finish at their own pace

### Level 2: User Team Mode (3+ headed sessions)

- Stop all new auto-dispatches immediately (Pool C budget = 0)
- Let all running Pool C tasks drain naturally
- Cecelia internal tasks also pause dispatching (Pool A budget = 0)
- System is fully yielded to the user

### Gradual Extinction (Not Cliff-Drop)

The existing pressure-based throttling already provides gradual reduction:
```
pressure < 0.5 → full capacity
pressure 0.5-0.7 → 2/3 capacity
pressure 0.7-0.9 → 1/3 capacity
pressure >= 0.9 → 1 slot
pressure >= 1.0 → 0 (hard stop)
```

With the new slot system, user presence acts as an additional "virtual pressure":
- 1 user session → reduce Pool C by headroom (2 slots)
- 3+ user sessions → Pool C = 0

This combines naturally with resource pressure for a smooth taper.

### Recovery: User Leaves

When `userMode` returns to `absent`:
- Pool C budget gradually restores to full
- No immediate burst of dispatches — rate limiting from alertness system still applies
- Cecelia internal tasks resume

---

## 7. Graceful Wind-Down Flow

```
User opens 1st headed session
  ↓
detectUserSessions() → { headed: 1, headless: 5 }
detectUserMode() → 'interactive'
calculateSlotBudget() → Pool C: 12 - (1+2) - 1 = 8
  ↓ (Pool C already has 5 running, below budget — no change needed)

User opens 3 more team agents
  ↓
detectUserSessions() → { headed: 4, headless: 5 }
detectUserMode() → 'team'
calculateSlotBudget() → Pool C: 12 - (4+2) - 0 = 6
  ↓ (Pool C has 5 running, below 6 — still OK but tight)

Team agents grow to 6
  ↓
detectUserSessions() → { headed: 6, headless: 5 }
calculateSlotBudget() → Pool C: 12 - (6+2) - 0 = 4
  ↓ Pool C has 5 running > budget 4 → STOP dispatching new
  ↓ Existing 5 tasks finish naturally (timeout or completion)
  ↓ As each finishes: Pool C running 4 → 3 → 2 → ...
  ↓ Never kills running tasks

User finishes, all headed sessions close
  ↓
detectUserSessions() → { headed: 0, headless: 2 }
detectUserMode() → 'absent'
calculateSlotBudget() → Pool C: 12 - 2 - 1 = 9
  ↓ Resume normal dispatching
```

---

## 8. Integration with Existing Systems

### Alertness

No change needed. Alertness evaluates system health independently. The slot allocation system is an **additional gate** before dispatch, not a replacement for alertness.

Dispatch happens only if BOTH pass:
1. Alertness allows dispatch (`canDispatch()` returns true)
2. Slot budget has room (`budget.taskPool.budget > autoDispatchActive`)

### Watchdog

No change needed. Watchdog monitors RSS/CPU per process and kills runaway processes regardless of pool. The slot system doesn't affect watchdog behavior.

### Circuit Breaker

No change needed. Circuit breaker gates the executor service availability, orthogonal to slot allocation.

### Drain Mode

Drain mode already stops dispatching and waits for tasks to finish — this is exactly the behavior we want for "user-priority mode". The new system adds automatic drain-like behavior when user is detected, without requiring manual `POST /api/brain/tick/drain`.

---

## 9. Implementation Plan

### Files to Modify

1. **`brain/src/slot-allocator.js`** (NEW) — Core slot allocation logic
   - `detectUserSessions()`
   - `detectUserMode(sessions)`
   - `calculateSlotBudget()`
   - `hasPendingInternalTasks()`
   - `countAutoDispatchInProgress()`
   - `getSlotStatus()` (for API)

2. **`brain/src/executor.js`** — Minor changes
   - Remove `INTERACTIVE_RESERVE` constant (replaced by slot allocator)
   - Update `getActiveProcessCount()` to report per-pool counts
   - Export `detectUserSessions` helper (or move to slot-allocator)

3. **`brain/src/tick.js`** — Dispatch gate change
   - Replace `AUTO_DISPATCH_MAX` check with `calculateSlotBudget().taskPool.budget`
   - Update `getTickStatus()` to include slot allocation info
   - Remove `AUTO_DISPATCH_MAX` constant (replaced by dynamic calculation)

4. **`brain/src/routes.js`** — New API endpoint
   - `GET /api/brain/slots` — returns `getSlotStatus()`
   - Update `/api/brain/vps-slots` to include pool classification

### Files NOT Modified

- `watchdog.js` — no change
- `alertness/` — no change
- `circuit-breaker.js` — no change
- `planner.js` — no change
- No database changes (no migration needed)
- No new dependencies

---

## 10. API: GET /api/brain/slots

```json
{
  "total_capacity": 12,
  "pools": {
    "user": {
      "budget": 4,
      "used": 2,
      "mode": "interactive",
      "sessions": [
        { "pid": 12345, "type": "headed" },
        { "pid": 12346, "type": "headed" }
      ]
    },
    "cecelia": {
      "budget": 1,
      "used": 0,
      "pending_internal_tasks": 0
    },
    "task_pool": {
      "budget": 7,
      "used": 5,
      "available": 2,
      "throttled_by": "none"
    }
  },
  "pressure": {
    "cpu": 0.42,
    "memory": 0.35,
    "swap": 0.0,
    "max": 0.42
  },
  "dispatch_allowed": true
}
```

---

## 11. Testing Strategy

### Unit Tests (slot-allocator.test.js)

1. `calculateSlotBudget()` with no user → Pool C = 9
2. `calculateSlotBudget()` with 1 headed → Pool C = 7  (12 - (1+2) - 1)
3. `calculateSlotBudget()` with 4 headed → Pool C = 4  (12 - (4+2) - 0) (team mode, cecelia yields)
4. `calculateSlotBudget()` with 8 headed → Pool C = 0  (12 - (8+2) = 2, but min 0)
5. `detectUserMode()` with 0/1/2/3/4 headed sessions
6. Pool C never goes negative
7. Under high pressure, Pool C further reduced
8. Cecelia budget = 0 when no internal tasks pending

### Integration Tests

1. Full tick cycle with user present → dispatch stops
2. User leaves → dispatch resumes
3. Concurrent Cecelia internal task + user session → both get slots
4. Resource pressure + user presence → compound reduction

---

## 12. Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| **1 Cecelia slot** (not 2) | Cecelia rarely does 2 internal tasks simultaneously. OKR decomposition and cortex RCA are sequential. |
| **On-demand reservation** | Don't waste a slot sitting idle. Reserve only when internal work is queued. |
| **Count-based detection** (not timing) | Simpler, more robust. 3+ headed = team. No need to track spawn timing. |
| **No process killing** | User's core concern is reliability. Graceful drain is always preferred. |
| **User headroom = 2** | User opens 1 session → keep 2 more free (total 3 available). Enough for team startup. |
| **No DB changes** | Slot allocation is runtime state, not persistent. Memory-only. Fast. |
| **New file, not inline** | `slot-allocator.js` is a focused module. Keeps executor.js and tick.js clean. |
